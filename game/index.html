<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PillWars - The Crypto Arena</title>
    
    <link rel="icon" href="../img/web.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Russo+One&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #00ff88; --primary-dim: rgba(0, 255, 136, 0.1); --accent: #ff2a2a;
            --classic-bg-1: #002211;
            --arcade-bg-1: #1a2200; 
            --bg-color: #050505; 
            --grid-line: rgba(255, 255, 255, 0.03);
            --text-main: #e0e0e0;
            --gold: #ffcc00;
        }
        html, body { touch-action: none; overflow: hidden; height: 100%; width: 100%; }
        
        body {
            margin: 0; background-color: var(--bg-color);
            background-image: linear-gradient(var(--grid-line) 1px, transparent 1px),
                              linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 40px 40px; font-family: 'Inter', sans-serif; 
            user-select: none; color: var(--text-main); 
            image-rendering: -webkit-optimize-contrast;
            transition: background-color 0.5s ease;
        }

        /* --- UI DESKTOP & SHARED --- */
        .sound-btn {
            position: absolute; top: 20px;
            width: 40px; height: 40px; z-index: 100;
            background: rgba(0,0,0,0.6); border: 1px solid #333; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: 0.2s; color: #fff;
        }
        .sound-btn:hover { background: rgba(255,255,255,0.1); border-color: #fff; }
        .sound-btn svg { width: 22px; height: 22px; fill: currentColor; }
        
        #soundToggle { right: 20px; } 
        #musicToggle { right: 70px; }
        #exitGameBtn { right: 120px; border-color: #522; color: #f55; display: none; }
        #exitGameBtn:hover { background: rgba(255, 50, 50, 0.2); border-color: #f00; color: #fff; }

        /* Bot√≥n Global Fullscreen (Visible siempre, estilo Desktop) */
        #globalFullscreenBtn {
            position: absolute; top: 20px; left: 20px; z-index: 200;
            background: rgba(0,0,0,0.6); border: 1px solid #333; color: white;
            padding: 8px 12px; border-radius: 6px; font-family: 'Russo One'; font-size: 12px;
            cursor: pointer; display: none; /* Oculto en PC por defecto, se activa con JS/Media */
        }

        .sound-on, .sound-off { display: block; } 
        .sound-btn:not(.muted) .sound-off { display: none !important; }
        .sound-btn:not(.muted) .sound-on { display: block !important; }
        .sound-btn.muted .sound-on { display: none !important; }
        .sound-btn.muted .sound-off { display: block !important; }

        .volume-slider-container {
            position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
            width: 30px; height: 120px; background: transparent; display: none; 
            flex-direction: column; align-items: center; padding-top: 10px; z-index: 150; cursor: default; 
        }
        .slider-bg {
            background: rgba(0,0,0,0.9); border: 1px solid #444; border-radius: 10px;
            padding: 10px 0; width: 100%; height: 100%; display: flex; justify-content: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #musicToggle:hover .volume-slider-container, .volume-slider-container:hover { display: flex; }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 80px; padding: 0 5px; cursor: pointer; 
        }

        #exitModal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 200; display: none; flex-direction: column; justify-content: center; align-items: center; animation: fadeIn 0.2s;
        }
        .exit-box { background: #111; border: 1px solid #444; border-radius: 12px; padding: 30px; text-align: center; width: 320px; box-shadow: 0 0 40px rgba(0,0,0,0.8); }
        .exit-title { color: #fff; font-family: 'Russo One'; font-size: 24px; margin-bottom: 10px; }
        .exit-desc { color: #aaa; font-size: 14px; margin-bottom: 25px; line-height: 1.5; }
        .exit-actions { display: flex; gap: 10px; }
        .btn-confirm { flex: 1; padding: 12px; border: none; background: #ff2a2a; color: #fff; font-weight: bold; border-radius: 6px; cursor: pointer; font-family: 'Russo One'; transition: 0.2s; }
        .btn-confirm:hover { background: #ff5555; }
        .btn-confirm:disabled { background: #555; cursor: wait; color: #aaa; }
        .btn-cancel { flex: 1; padding: 12px; border: 1px solid #444; background: transparent; color: #ccc; font-weight: bold; border-radius: 6px; cursor: pointer; font-family: 'Russo One'; }
        .btn-cancel:hover { border-color: #fff; color: #fff; }

        #buffTable {
            position: absolute; top: 100px; left: 15px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; color: white; padding: 15px; border-radius: 12px; width: 180px; pointer-events: none; z-index: 20; font-size: 12px; display: none;
        }
        #buffTable h3 { font-family: 'Russo One'; color: #888; border-bottom: 1px solid #333; padding-bottom: 8px; margin-bottom: 10px; font-size: 14px; letter-spacing: 1px; }
        .buff-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .buff-icon-img { width: 48px; height: 48px; object-fit: contain; filter: drop-shadow(0 0 6px rgba(255,255,255,0.4)); background: rgba(255,255,255,0.08); border-radius: 6px; padding: 3px; border: 1px solid #444; }
        .buff-time { color: var(--primary); font-family: 'Russo One'; font-size: 18px; text-shadow: 0 0 5px rgba(0,255,136,0.5); }

        /* --- MODE SCREEN (DESKTOP DEFAULT) --- */
        #modeScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: flex; overflow: hidden; background: #000; transition: opacity 0.5s; }
        .mode-panel { position: absolute; top: 0; bottom: 0; width: 100%; transition: clip-path 1.2s cubic-bezier(0.4, 0, 0.2, 1), filter 0.85s; cursor: pointer; display: flex; flex-direction: column; justify-content: center; padding: 0 10%; box-sizing: border-box; }
        
        .mode-arcade {
            background-image: linear-gradient(rgba(204, 255, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(204, 255, 0, 0.05) 1px, transparent 1px), linear-gradient(135deg, var(--arcade-bg-1) 0%, #000 100%);
            background-size: 50px 50px, 50px 50px, 100% 100%; clip-path: polygon(0 0, 65% 0, 55% 100%, 0 100%); left: 0; z-index: 2; align-items: flex-start; text-align: left;
        }
        .mode-classic {
            background-image: linear-gradient(rgba(0, 255, 136, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 136, 0.05) 1px, transparent 1px), linear-gradient(135deg, #000 0%, var(--classic-bg-1) 100%);
            background-size: 50px 50px, 50px 50px, 100% 100%; clip-path: polygon(65% 0, 100% 0, 100% 100%, 55% 100%); right: 0; z-index: 2; align-items: flex-end; text-align: right;
        }
        /* HOVER EFFECTS DESKTOP */
        #modeScreen.hover-arcade .mode-arcade { clip-path: polygon(0 0, 80% 0, 70% 100%, 0 100%); filter: brightness(1.2); }
        #modeScreen.hover-arcade .mode-classic { clip-path: polygon(80% 0, 100% 0, 100% 100%, 70% 100%); filter: brightness(0.5); }
        #modeScreen.hover-classic .mode-arcade { clip-path: polygon(0 0, 30% 0, 20% 100%, 0 100%); filter: brightness(0.5); }
        #modeScreen.hover-classic .mode-classic { clip-path: polygon(30% 0, 100% 0, 100% 100%, 20% 100%); filter: brightness(1.2); }
        
        .diagonal-divider { position: absolute; top: -10%; width: 6px; height: 120%; background: #fff; z-index: 10; box-shadow: 0 0 40px #fff, 0 0 10px #fff; pointer-events: none; transition: left 1.2s cubic-bezier(0.4, 0, 0.2, 1); transform: rotate(10deg); left: 60%; }
        #modeScreen.hover-arcade .diagonal-divider { left: 75%; background: #ccff00; box-shadow: 0 0 40px #ccff00; }
        #modeScreen.hover-classic .diagonal-divider { left: 25%; background: #00ff88; box-shadow: 0 0 40px #00ff88; }
        
        .mode-content { position: absolute; top: 50%; transform: translateY(-50%); transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1); max-width: 500px; opacity: 0.9; pointer-events: none; }
        #contentArcade { text-align: left; left: 32.5%; transform: translate(-50%, -50%) scale(1.1); }
        #contentClassic { text-align: right; left: 82.5%; transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
        
        /* HOVER CONTENT POSITIONS */
        #modeScreen.hover-arcade #contentArcade { left: 50%; transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        #modeScreen.hover-arcade #contentClassic { left: 85%; transform: translate(-50%, -50%) scale(0.8) translateX(30px); opacity: 0.7; }
        #modeScreen.hover-classic #contentArcade { left: 15%; transform: translate(-50%, -50%) scale(0.8) translateX(-30px); opacity: 0.7; }
        #modeScreen.hover-classic #contentClassic { left: 50%; transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        
        .mode-title { font-family: 'Russo One'; font-size: 70px; text-transform: uppercase; margin-bottom: 10px; letter-spacing: 2px; text-shadow: 0 0 30px rgba(0,0,0,0.9); transition: all 0.4s; }
        .mode-desc { font-size: 14px; color: #fff; margin-bottom: 25px; font-weight: 500; line-height: 1.6; text-shadow: 0 2px 4px #000; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); }
        .highlight { color: #fff; font-weight: 800; }
        .mode-sub { font-size: 12px; text-transform: uppercase; color: #888; letter-spacing: 2px; margin-bottom: 5px; font-family: 'Russo One';}
        .mode-classic .mode-title { color: #00ffaa; }
        .mode-arcade .mode-title { color: #ccff00; }
        
        .mode-panel.expanded { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%) !important; z-index: 40; filter:brightness(1) !important; width:100% !important; height:100% !important; top:0 !important; left:0 !important; }
        .mode-panel.hidden { opacity: 0; pointer-events: none; }

        /* --- LOGIN OVERLAY --- */
        #loginOverlay, #resultOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(8px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 60; }
        #loginOverlay.bg-classic { background-image: linear-gradient(rgba(0, 255, 136, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 136, 0.05) 1px, transparent 1px), linear-gradient(135deg, var(--classic-bg-1) 0%, #000 100%); background-size: 50px 50px, 50px 50px, 100% 100%; }
        #loginOverlay.bg-arcade { background-image: linear-gradient(rgba(204, 255, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(204, 255, 0, 0.05) 1px, transparent 1px), linear-gradient(135deg, #000 0%, var(--arcade-bg-1) 100%); background-size: 50px 50px, 50px 50px, 100% 100%; }
        
        .login-box { 
            background: rgba(10, 15, 10, 0.95); border: 1px solid var(--primary); 
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.15); padding: 20px; 
            border-radius: 12px; text-align: center; width: 850px; 
            max-width: 95%; display: flex; flex-direction: column; 
            animation: slideUp 0.4s ease-out; position: relative; 
            overflow: visible; transition: width 0.3s ease; 
            max-height: 95vh;
        }
        
        .login-content-wrapper { display: flex; gap: 30px; width: 100%; margin-top: 10px; text-align: left; }
        .login-left { flex: 1; min-width: 320px; }
        .login-right { flex: 1; background: rgba(0,0,0,0.3); border-left: 1px solid #333; padding-left: 20px; display: flex; flex-direction: column; }
        
        details.advanced-settings { position: relative; margin: -5px 0 10px 0; }
        summary {
            background: #111; border: 1px solid #333; border-radius: 6px;
            padding: 10px; cursor: pointer; font-weight: bold; color: #888;
            user-select: none; font-size: 11px; font-family: 'Russo One';
            letter-spacing: 1px; transition: 0.2s; outline: none;
            display: flex; align-items: center; justify-content: space-between;
            list-style: none;
        }
        summary:hover { color: #fff; border-color: var(--primary); background: #222; }
        summary::-webkit-details-marker { display: none; }
        summary::after { content: '‚óÄ'; font-size: 10px; transition: transform 0.2s; }
        details[open] summary { color: #fff; border-color: #fff; background: #222; }
        details[open] summary::after { transform: rotate(180deg); } 

        .options-content {
            position: absolute;
            right: 105%; top: 50%; transform: translate(20px, -50%);
            width: 280px; background: rgba(15, 15, 15, 0.98);
            border: 1px solid var(--primary); border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); padding: 15px;
            z-index: 1000; backdrop-filter: blur(10px);
            display: flex; flex-direction: column; gap: 10px;
            opacity: 0; animation: slideOutLeft 0.2s forwards ease-out;
        }

        @keyframes slideOutLeft { to { opacity: 1; transform: translate(0, -50%); } }

        /* --- MOBILE OPTIMIZATIONS (LANDSCAPE SPECIFIC) --- */
        /* Asegura que esto NO afecta a Desktop normal, solo a pantallas peque√±as */
        @media (max-width: 920px) {
            
            /* Mostrar bot√≥n de fullscreen global */
            #globalFullscreenBtn { display: block; }
            #exitGameBtn { display: none !important; } /* Ocultar el de PC */

            /* 1. MODO SELECCI√ìN: Partir pantalla en 2 sin diagonales */
            #modeScreen { flex-direction: row; }
            .diagonal-divider { display: none; }
            
            .mode-panel {
                width: 50% !important; height: 100% !important;
                clip-path: none !important; /* Quitar recortes */
                top: 0 !important; bottom: 0 !important;
                padding: 10px !important;
                display: flex; align-items: center; justify-content: center;
                text-align: center;
            }
            .mode-arcade { left: 0; border-right: 2px solid #333; align-items: center; }
            .mode-classic { right: 0; left: auto; align-items: center; }

            .mode-content {
                position: relative; left: auto !important; top: auto !important;
                transform: none !important; opacity: 1 !important; width: 100%;
                margin: 0;
            }
            #contentArcade, #contentClassic { text-align: center; }

            .mode-title { font-size: 28px; margin-bottom: 5px; }
            .mode-sub { font-size: 10px; }
            .mode-desc { display: none; } /* Ocultar texto largo */

            /* 2. LOGIN BOX: Compacto con Scroll */
            .login-box {
                width: 96%; height: 96%; max-height: 96%;
                padding: 10px; 
                display: flex; flex-direction: column;
                overflow: hidden; /* Evitar scroll en el body overlay */
            }
            
            .login-content-wrapper {
                flex: 1; overflow-y: auto; /* Scroll interno vital */
                display: flex; flex-direction: row; gap: 15px;
                padding-bottom: 40px; /* Espacio para el dedo al hacer scroll */
            }

            .login-left { 
                flex: 1; min-width: 0; 
                display: flex; flex-direction: column; gap: 5px;
            }
            .login-right {
                flex: 1; min-width: 0;
                border-left: 1px solid #333; padding-left: 10px; margin-top: 0; border-top: none;
                background: transparent;
            }

            /* Reducciones de tama√±o */
            .section-title { font-size: 9px; margin: 5px 0 2px; }
            .srv-btn, .q-btn { padding: 4px 0; font-size: 10px; }
            input[type="text"] { padding: 6px; font-size: 11px; }
            .btn-play { padding: 10px; font-size: 16px; margin-top: 15px; }
            .btn-spectate { padding: 8px; font-size: 12px; margin-top: 5px; }
            .ultra-btn { font-size: 9px; padding: 5px; }
            
            /* Ajuste de opciones avanzadas para que no floten fuera */
            .options-content {
                position: static; transform: none; width: 100%; 
                opacity: 1; animation: none; margin-top: 10px;
                background: rgba(0,0,0,0.5);
            }

            /* Arcade/Classic Guide Panel en Login */
            .arcade-objective { font-size: 9px; padding: 5px; margin-bottom: 5px; }
            .grid-skill-icon { width: 35px; height: 35px; }
            .card-header { font-size: 12px; }
            .card-video-box { min-height: 80px; height: 100px !important; }
            #cardSkillDesc { font-size: 9px; height: 40px; line-height: 1.1; }
            .split-video { height: 100px; }
        }

        .skills-grid-title { font-family: 'Russo One'; font-size: 12px; color: #666; margin-bottom: 10px; letter-spacing: 1px; }
        .skills-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
        .grid-skill-icon { width: 50px; height: 50px; background-color: #1a1a1a; border: 2px solid #444; border-radius: 8px; cursor: pointer; transition: all 0.2s; background-size: 80%; background-position: center; background-repeat: no-repeat; position: relative; }
        .grid-skill-icon:hover { border-color: #fff; box-shadow: 0 0 15px var(--primary); transform: scale(1.1); z-index: 10; }
        .grid-skill-icon.selected { border-color: #ccff00; box-shadow: 0 0 20px #ccff00; background-color: #222; }
        
        /* ESTILO GENERAL (Flexible para Classic Mode) */
        .skill-info-card { 
            background: #000; border: 1px solid #444; border-radius: 4px; padding: 15px; 
            flex-grow: 1; display: flex; flex-direction: column; position: relative; 
            box-shadow: inset 0 0 30px rgba(0,0,0,0.8);
        }
        
        /* ESTILO ESPECIFICO PARA ARCADE (Fijo para evitar saltos) */
        #skillInfoCard {
            min-height: 280px; 
            justify-content: space-between;
        }

        .card-header { font-family: 'Russo One'; font-size: 18px; color: #fff; margin-bottom: 10px; text-transform: uppercase; }
        
        /* VIDEO CARD STYLE GENERAL */
        .card-video-box { 
            width: 100%; 
            flex-grow: 1; 
            border: 1px solid #333; 
            border-radius: 4px;     
            margin-bottom: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: #000; 
            overflow: hidden; 
            min-height: 140px;
        }
        
        /* VIDEO CARD STYLE ESPECIFICO ARCADE */
        #skillInfoCard .card-video-box {
            height: 160px;
            min-height: 160px;
            flex-grow: 0;
        }

        .card-video-player { width: 100%; height: 100%; object-fit: cover; }
        
        /* CAJA DE TEXTO CON ALTURA FIJA SOLO PARA ARCADE */
        #cardSkillDesc {
            margin-top: 10px;
            font-size: 11px;
            color: #ccc;
            line-height: 1.4;
            height: 55px; /* Altura fija para evitar saltos */
            overflow: hidden; 
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        
        .split-gif-placeholder { width: 100%; height: 100px; background: #000; border: 1px dashed #444; display: flex; justify-content: center; align-items: center; color: #555; margin-bottom: 5px; font-size: 10px; font-weight: bold; }
        .split-explanation { font-size: 11px; color: #aaa; line-height: 1.4; padding-right: 25px; position: relative; height: 45px; overflow: hidden; }
        
        .split-guide-box { margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; position: relative; }
        .split-video { width: 100%; height: 200px; border-radius: 4px; display: block; border: 1px solid #333; margin-bottom: 5px; background: #000; object-fit: contain; }
        
        .guide-next-arrow {
            position: absolute; bottom: 0; right: 0; background: none; border: none; color: #555; font-size: 20px; cursor: pointer; padding: 5px; transition: 0.2s;
        }
        .guide-next-arrow:hover { color: #00ffaa; transform: scale(1.2); }

        @media (max-height: 700px) { .grid-skill-icon { width: 40px; height: 40px; } }
        .result-box { background: rgba(10, 15, 10, 0.95); border: 1px solid var(--primary); box-shadow: 0 0 50px rgba(0, 255, 136, 0.15); padding: 20px 30px; border-radius: 12px; text-align: center; width: 380px; animation: slideUp 0.4s ease-out; position: relative; max-height: 95vh; overflow-y: auto; }
        @keyframes slideUp { from {transform:translateY(20px); opacity:0;} to {transform:translateY(0); opacity:1;} }
        .back-icon { position: absolute; top: 15px; left: 15px; width: 30px; height: 30px; cursor: pointer; background: rgba(255,255,255,0.1); border-radius: 6px; display: flex; justify-content: center; align-items: center; transition: 0.2s; border: 1px solid #333; }
        .back-icon:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        .back-icon svg { width: 16px; height: 16px; fill: #ccc; }
        h1 { margin: 0 0 5px 0; color: #fff; font-family: 'Russo One'; font-size: 28px; text-transform: uppercase; }
        #selectedModeTitle { font-family: 'Russo One'; font-size: 18px; text-transform: uppercase; margin: 0 0 15px 0; padding-bottom: 10px; border-bottom: 1px solid #333; letter-spacing: 2px; }
        .section-title { font-family: 'Russo One'; font-size: 10px; color: var(--primary); text-transform: uppercase; margin: 10px 0 5px; text-align: left; letter-spacing: 1px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .server-selector { display: flex; gap: 5px; margin-bottom: 5px; }
        .srv-btn { flex: 1; padding: 8px 0; background: #111; border: 1px solid #333; border-radius: 4px; cursor: pointer; font-weight: 700; color: #666; transition: 0.2s; font-family: 'Inter'; font-size: 12px; }
        .srv-btn:hover { border-color: var(--primary); color: #fff; }
        .srv-btn.selected { background: var(--primary); color: #000; border-color: var(--primary); }
        .style-type-selector { display: flex; gap: 15px; margin-bottom: 15px; justify-content: center; display:none; }
        .style-type-selector label { font-size: 12px; font-weight: 600; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 5px; }
        .color-pickers { display: flex; gap: 10px; margin-bottom: 15px; background: #151515; padding: 10px; border-radius: 6px; border: 1px solid #333; }
        .cp-group { flex: 1; display: flex; flex-direction: column; }
        input[type="color"] { border: none; width: 100%; height: 30px; cursor: pointer; background: none; padding: 0;}
        input[type="text"] { width: 100%; padding: 10px; font-size: 13px; border: 1px solid #333; border-radius: 6px; text-align: center; background: #000; color: #fff; box-sizing: border-box; }
        
        .quality-buttons { display: flex; gap: 5px; margin: 5px 0; }
        .q-btn { flex: 1; padding: 6px 0; background: #111; border: 1px solid #333; border-radius: 4px; cursor: pointer; font-weight: 700; color: #666; transition: 0.2s; font-family: 'Inter'; font-size: 11px; }
        .q-btn:hover { border-color: #fff; color: #fff; }
        .q-btn.selected { background: #333; color: #fff; border-color: #fff; }
        
        .ultra-btn { width: 100%; padding: 8px 0; background: #200; border: 1px solid #522; border-radius: 4px; cursor: pointer; font-weight: 800; color: #f55; transition: 0.2s; font-family: 'Inter'; font-size: 10px; margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .ultra-btn:hover { background: #300; border-color: #f00; color: #fff; }
        .ultra-btn.selected { background: #f00; color: #000; border-color: #f00; }

        .btn-play { width: 100%; padding: 12px; margin-top: 10px; background: var(--accent); color: white; border: none; font-family: 'Russo One'; font-size: 18px; letter-spacing: 1px; clip-path: polygon(0 0, 100% 0, 100% 70%, 95% 100%, 0 100%); cursor: pointer; transition: 0.2s; text-transform: uppercase; }
        .btn-play:hover { transform: scale(1.02); filter: brightness(1.2); box-shadow: 0 0 20px rgba(255, 42, 42, 0.4); }
        .btn-reset { width: 100%; padding: 6px; margin-top: 5px; background: transparent; border: 1px dashed #333; color: #555; font-size: 10px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .btn-reset:hover { border-color: var(--primary); color: var(--primary); }
        
        .btn-spectate { width: 100%; padding: 12px; margin-top: 10px; background: #00bcd4; color: white; border: none; font-family: 'Russo One'; font-size: 18px; letter-spacing: 1px; clip-path: polygon(0 0, 100% 0, 100% 70%, 95% 100%, 0 100%); cursor: pointer; transition: 0.2s; text-transform: uppercase; }
        .btn-spectate:hover { transform: scale(1.02); filter: brightness(1.2); box-shadow: 0 0 20px rgba(0, 188, 212, 0.4); }

        #ui { position: absolute; top: 15px; left: 15px; color: #fff; font-family: 'Russo One'; font-size: 14px; pointer-events: none; z-index: 10; text-shadow: 0 2px 4px #000; display: none; gap: 15px; }
        .hud-item { background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }
        .hud-val { color: var(--primary); }
        #timerDisplay { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #fff; font-family: 'Russo One'; font-size: 24px; text-shadow: 0 0 10px var(--primary); pointer-events: none; z-index: 10; display: none;}
        #leaderboard { position: absolute; top: 75px; right: 15px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; color: white; padding: 10px; border-radius: 8px; width: 160px; pointer-events: none; z-index: 10; font-size: 12px; display: none; }
        #leaderboard h3 { font-family: 'Russo One'; color: #888; border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 5px; font-size: 12px; letter-spacing: 1px; }
        .lb-item { display: flex; justify-content: space-between; margin-bottom: 4px; font-weight: 600; }
        .is-me { color: var(--primary); text-shadow: 0 0 5px var(--primary-dim); }
        .winner-list { list-style: none; padding: 0; margin: 15px 0; text-align: left; width: 100%; }
        .winner-item { padding: 10px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; font-weight: bold; color: #ccc; }
        .winner-item span:last-child { color: var(--primary); font-family: 'Russo One'; }
        #actionBar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 8px; z-index: 15; padding: 8px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 12px; pointer-events: auto; backdrop-filter: blur(5px); }
        .ab-slot { width: 50px; height: 50px; background: #151515; border: 2px solid #333; border-radius: 8px; position: relative; display: flex; justify-content: center; align-items: center; transition: transform 0.1s; overflow: hidden; cursor: grab; }
        .ab-slot:active { cursor: grabbing; }
        .ab-slot.active { transform: scale(0.95); border-color: var(--primary); box-shadow: 0 0 10px var(--primary-dim); }
        .skill-opt-btn.selected-choice { border-color: #fff !important; background: #444 !important; transform: scale(1.15) !important; box-shadow: 0 0 25px rgba(255, 255, 255, 0.5) !important; z-index: 100; }
        .count-badge { position: absolute; bottom: 1px; right: 1px; background: var(--accent); color: white; border-radius: 3px; padding: 0 3px; font-size: 8px; font-weight: bold; z-index: 5; }
        .gcd-badge { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: #fff; font-family: 'Russo One'; font-size: 16px; text-shadow: 0 0 5px #000; z-index: 10; pointer-events: none;}
        .skill-icon { width: 100%; height: 100%; background-size: 90%; background-position: center; background-repeat: no-repeat; opacity: 0.9; pointer-events: none; }
        /* CORREGIDO: Rutas a im√°genes con ../ */
        .icon-clon { background-image: url('../img/clon.png'); background-color:#333; }
        .icon-shot { background-image: url('../img/shoot.png'); background-color:#333; }
        .icon-sprint { background-image: url('../img/sprint.png'); background-color:#333; }
        .icon-tp { background-image: url('../img/tp.png'); background-color:#333; }
        .icon-magnet { background-image: url('../img/iman.png'); background-color:#333; }
        .icon-shield { background-image: url('../img/inmune.png'); background-color:#333; }
        .icon-big { background-image: url('../img/big.png'); background-color:#333; }
        .icon-random { background-image: url('../img/random.png'); background-color:#333; }
        .icon-empty { background-color: #111; }
        .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.8); transition: height 0.1s linear; z-index: 2; pointer-events: none; }
        .active-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0, 255, 136, 0.3); transition: height 0.1s linear; z-index: 2; pointer-events: none; }
        .bot-config-box { background: transparent; padding: 5px 0; border-radius: 8px; display: flex; flex-direction: column; gap: 10px; }
        .bot-row { display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-weight: 600; color: #ccc; }
        .slider-container { display: flex; align-items: center; gap: 10px; width: 100%; }
        input[type="range"] { flex-grow: 1; accent-color: var(--primary); }
        .val-display { font-family: 'Russo One'; color: var(--primary); width: 30px; text-align: right;}
        #skillChoiceOverlay { position: absolute; top: 5%; left: 50%; transform: translateX(-50%); width: 500px; z-index: 55; display: none; flex-direction: column; align-items: center; pointer-events: auto; }
        .skill-choice-card { background: rgba(0,0,0,0.9); border: 2px solid var(--primary); border-radius: 12px; padding: 30px; text-align: center; width: 100%; margin-bottom: 10px; box-shadow: 0 0 50px rgba(0,255,136,0.3); animation: fadeIn 0.3s; }
        .skill-options { display: flex; gap: 30px; justify-content: center; margin-top: 20px; }
        .skill-opt-btn { width: 100px; height: 100px; background: #222; border: 2px solid #555; border-radius: 15px; cursor: pointer; transition: 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .skill-opt-btn:hover { border-color: #fff; transform: scale(1.1); background: #333; }
        .skill-opt-icon { width: 50px; height: 50px; background-size: contain; background-repeat: no-repeat; background-position: center; margin-bottom: 10px; }
        .skill-opt-name { font-size: 12px; font-weight: bold; color: #ccc; text-transform: uppercase; }
        .timer-bar { width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 15px; }
        .timer-fill { height: 100%; background: var(--accent); width: 100%; transition: width 1s linear; }
        .skill-tips { margin-top: 10px; font-size: 10px; color: #777; font-weight: bold; letter-spacing: 1px; animation: blink 2s infinite; }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- TOOLTIP FLOTANTE (ESTILO INDEX) --- */
        .skill-tooltip {
            position: fixed; width: 250px;
            background: rgba(10, 10, 10, 0.98); border: 2px solid var(--gold); border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,1), 0 0 20px rgba(255, 204, 0, 0.3);
            z-index: 999999; display: none; flex-direction: column;
            backdrop-filter: blur(10px); pointer-events: none; text-align: left;
            animation: fadeInTooltip 0.15s ease-out;
        }
        @keyframes fadeInTooltip { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .tooltip-img-container {
            width: 100%; height: 100px; background: #000; border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: center; border-radius: 6px 6px 0 0;
            position: relative; overflow: hidden;
        }
        .tooltip-img-bg {
            position: absolute; width: 100%; height: 100%; 
            background-size: cover; background-position: center; opacity: 0.3; filter: blur(5px);
        }
        .tooltip-icon-main { width: 50px; height: 50px; z-index: 2; filter: drop-shadow(0 0 10px var(--gold)); }

        .tooltip-content { padding: 15px; }
        .tooltip-title { color: #fff; font-family: 'Russo One'; font-size: 16px; margin: 0 0 5px 0; text-transform: uppercase; }
        .tooltip-divider { width: 40px; height: 3px; background: var(--gold); margin-bottom: 10px; }
        .tooltip-desc { color: #ccc; font-size: 11px; line-height: 1.4; margin-bottom: 15px; }

        /* --- CONTROLES M√ìVILES (SOLO VISIBLES EN M√ìVIL) --- */
        #mobileControls {
            display: none; /* Por defecto oculto, se activa con JS/Media */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 999;
        }

        @media (max-width: 900px) {
            #mobileControls { display: block; }
            #actionBar { display: none !important; } /* Ocultar barra arcade de escritorio */
            #exitGameBtn { display: none; }
        }

        /* JOYSTICK */
        #joystickZone {
            position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        /* BOTONES DE ACCI√ìN */
        #mobileActions {
            position: absolute; bottom: 40px; right: 40px;
            display: flex; gap: 15px; align-items: flex-end;
            pointer-events: auto;
        }
        .mob-btn {
            width: 60px; height: 60px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff; font-family: 'Russo One'; font-size: 12px;
            display: flex; justify-content: center; align-items: center;
            touch-action: manipulation; user-select: none; -webkit-user-select: none;
        }
        .mob-btn:active { background: rgba(255, 255, 255, 0.3); transform: scale(0.95); }
        .mob-big { width: 70px; height: 70px; font-size: 14px; background: rgba(255, 42, 42, 0.3); border-color: rgba(255, 42, 42, 0.6); }

        /* ORIENTATION WARNING */
        #orientationLock {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; font-family: 'Russo One'; text-align: center;
        }
        @media screen and (orientation: portrait) and (max-width: 900px) {
            #orientationLock { display: flex; }
        }

        /* ARCADE MOBILE SLOTS */
        .arcade-mob-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;
            margin-right: 10px;
        }
        .mob-skill-slot {
            width: 50px; height: 50px; background: rgba(0,0,0,0.6); border: 1px solid #555;
            border-radius: 8px; position: relative;
        }
        .mob-skill-slot.active { border-color: var(--primary); }
    </style>
</head>
<body>

    <!-- GLOBAL FULLSCREEN BUTTON (PC HIDDEN, MOBILE VISIBLE) -->
    <div id="globalFullscreenBtn" onclick="toggleFullScreen()">‚õ∂ FULLSCREEN</div>

    <!-- MOBILE CONTROLS (Solo visible en m√≥vil) -->
    <div id="orientationLock">
        <svg fill="#fff" width="64px" height="64px" viewBox="0 0 24 24"><path d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 18.29 0 12 0l-1 .08v3.02h1c1.61 0 3.09.55 4.48 1.42zM19.48 13c-.36 3.76-2.7 6.93-5.97 8.48l-.03.02 1.49 1.49C16.11 21.55 17.6 21 19.48 13zM0 12c0 6.62 5.38 12 12 12h1v-3.02l-1 .02c-5.17 0-9.41-3.87-9.95-8.8H.05v-.2h2.03C2.59 7.07 6.83 3.2 12 3.2l1-.02V.18H12C5.38.18 0 5.54 0 12zM12 18l4-4-4-4v8z"/></svg>
        <div style="margin-top:20px;">PLEASE ROTATE DEVICE</div>
    </div>

    <div id="mobileControls">
        <div id="joystickZone"><div id="stick"></div></div>
        
        <div id="mobileActions">
            <!-- Arcade Skills Container (4 slots) -->
            <div id="mobArcadeSlots" class="arcade-mob-grid" style="display:none;">
                <div class="mob-btn mob-skill-slot" id="mobSlot1" ontouchstart="activateSkillTouch(1, event)"></div>
                <div class="mob-btn mob-skill-slot" id="mobSlot2" ontouchstart="activateSkillTouch(2, event)"></div>
                <div class="mob-btn mob-skill-slot" id="mobSlot3" ontouchstart="activateSkillTouch(3, event)"></div>
                <div class="mob-btn mob-skill-slot" id="mobSlot4" ontouchstart="activateSkillTouch(4, event)"></div>
            </div>

            <!-- Bot√≥n Shoot (Solo Classic) -->
            <div id="mobShootBtn" class="mob-btn" style="display:none;" ontouchstart="activateSkillTouch(1, event)">SHOOT</div>
            
            <!-- Bot√≥n Split (Com√∫n) -->
            <div class="mob-btn mob-big" ontouchstart="splitPlayerMobile(event)">SPLIT</div>
        </div>
    </div>

 <!-- BOTONES SONIDO/MUSICA Y SALIDA -->
    <div id="soundToggle" class="sound-btn" onclick="toggleAudio()" title="Sound Effects">
        <svg class="sound-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
        <svg class="sound-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
    </div>

    <div id="musicToggle" class="sound-btn" onclick="toggleMusic()" title="Music">
        <svg class="sound-on" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e3e3e3"><path d="M400-120q-66 0-113-47t-47-113q0-66 47-113t113-47q23 0 42.5 5.5T480-418v-422h240v160H560v400q0 66-47 113t-113 47Z"/></svg>
        <svg class="sound-off" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e3e3e3"><path d="M792-56 56-792l56-56 736 736-56 56ZM560-514l-80-80v-246h240v160H560v166ZM400-120q-66 0-113-47t-47-113q0-66 47-113t113-47q23 0 42.5 5.5T480-418v-62l80 80v120q0 66-47 113t-113 47Z"/></svg>
        <div class="volume-slider-container">
            <div class="slider-bg">
                <input type="range" min="0" max="0.5" step="0.02" value="0.25" orient="vertical" oninput="SoundManager.setVolume(this.value)" onclick="event.stopPropagation()">
            </div>
        </div>
    </div>

    <div id="exitGameBtn" class="sound-btn" onclick="toggleExitModal()" title="Quit Game">
        <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
    </div>

    <div id="exitModal">
        <div class="exit-box">
            <div class="exit-title" id="exitModalTitle">LEAVE ARENA?</div>
            <div class="exit-desc" id="exitModalDesc">You will lose your current mass and progress. Are you sure?</div>
            <div class="exit-actions">
                <button class="btn-cancel" onclick="toggleExitModal()" onmouseenter="SoundManager.playSimpleHover()">CANCEL</button>
                <button class="btn-confirm" id="btnConfirmExit" onclick="confirmExit()" onmouseenter="SoundManager.playSimpleHover()">EXIT</button>
            </div>
        </div>
    </div>

    <div id="modeScreen">
        <div class="diagonal-divider"></div>
        <div id="panelArcade" class="mode-panel mode-arcade" onmouseenter="tryPlayHover('arcade'); setHoverMode('arcade')" onclick="selectMode('arcade')">
            <div id="contentArcade" class="mode-content">
                <div class="mode-sub">ROGUELIKE MECHANICS</div>
                <div class="mode-title">ARCADE</div>
                <div class="mode-desc">
                    NORMAL MAP. TIME: <span class="highlight">3:50</span>.<br>
                    START EMPTY. <span class="highlight">PICK SKILLS</span> EVERY 30S.<br>
                    <span style="color:#ccff00;">REACH TOP 5 TO WIN.</span>
                </div>
            </div>
        </div>
        <div id="panelClassic" class="mode-panel mode-classic" onmouseenter="tryPlayHover('classic'); setHoverMode('classic')" onclick="selectMode('classic')">
            <div id="contentClassic" class="mode-content">
                <div class="mode-sub">STANDARD MODE</div>
                <div class="mode-title">CLASSIC</div>
                <div class="mode-desc">
                    NO TIMER. <span class="highlight">HUGE MAP (x2)</span>.<br>
                    ONLY <span class="highlight">SHOOT</span> SKILL (KEY 1).<br>
                    <span style="color:#00ffaa;">PURE CELL-EATING GAMES EXPERIENCE.</span>
                </div>
            </div>
        </div>
    </div>

    <div id="loginOverlay">
        <div class="login-box">
            <div class="back-icon" onclick="goBackToModes()">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </div>
            <h1>PillWars</h1>
            <h2 id="selectedModeTitle">MODE SELECTED</h2>
            <div id="gameOverMsg" style="display:none; color:#ff2a2a; font-weight:bold; margin-bottom:10px;">GAME OVER</div>

            <div class="login-content-wrapper">
                <div class="login-left">
                    <div class="section-title">1. Room Select (Token amount depends on $PILL price)</div>
                    <div class="server-selector">
                        <button class="srv-btn selected" onclick="selectServer('5$', this)">5$</button>
                        <button class="srv-btn" onclick="selectServer('10$', this)">10$</button>
                        <button class="srv-btn" onclick="selectServer('20$', this)">20$</button>
                        <button class="srv-btn" onclick="selectServer('50$', this)">50$</button>
                    </div>
                    <!-- FREE ROOM BELOW PAYMENT ROOMS -->
                    <button class="srv-btn" style="width:100%; margin-bottom:5px; border-color:var(--primary); color:var(--primary);" onclick="selectServer('Free', this)">PRACTICE (FREE)</button>
                    
                    <button class="btn-reset" onclick="forceResetRoom()">‚ö† RESET CURRENT ROOM ‚ö†</button>

                    <div class="section-title">2. Character</div>
                    <!-- RADIO BUTTONS HIDDEN (COLORS ONLY DEFAULT) -->
                    <div class="style-type-selector" style="display:none;">
                        <label><input type="radio" name="styleMode" value="color" checked onclick="toggleStyleUI()"> Colors</label>
                        <label><input type="radio" name="styleMode" value="skin" onclick="toggleStyleUI()"> Skin URL</label>
                    </div>
                    
                    <div id="colorPickersContainer" class="color-pickers">
                        <div class="cp-group"><label>Top</label><input type="color" id="colTop" value="#ffffff"></div>
                        <div class="cp-group"><label>Base</label><input type="color" id="colBot" value="#00ff88"></div>
                    </div>
                    
                    <div id="skinInputContainer" style="display:none;"></div>

                    <div class="section-title">3. Nickname</div>
                    <input type="text" id="playerNameInput" placeholder="Enter Nickname..." maxlength="12">
                    
                    <div class="section-title" style="margin-top:15px;">Graphics Quality</div>
                    <div class="quality-buttons">
                        <button class="q-btn" id="qHigh" onclick="setQuality('high')">HIGH</button>
                        <button class="q-btn selected" id="qNormal" onclick="setQuality('normal')">NORMAL</button>
                        <button class="q-btn" id="qLow" onclick="setQuality('low')">LOW</button>
                    </div>

                    <div class="section-title" style="margin-top:15px;">Map Theme</div>
                    <div style="display:flex; gap:15px; margin-bottom:5px;">
                        <label style="color:#aaa; font-size:11px; font-weight:bold; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="themeMode" value="dark" checked onclick="setTheme('dark')"> Dark
                        </label>
                        <label style="color:#aaa; font-size:11px; font-weight:bold; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="themeMode" value="grey" onclick="setTheme('grey')"> Grey
                        </label>
                        <label style="color:#aaa; font-size:11px; font-weight:bold; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="themeMode" value="white" onclick="setTheme('white')"> White
                        </label>
                    </div>

                    <details class="advanced-settings">
                        <summary>‚öôÔ∏è ADVANCED SETTINGS</summary>
                        <div class="options-content">
                            <div id="settingsLock" style="padding:20px 10px; text-align:center;">
                                <div style="font-size:10px; color:#aaa; margin-bottom:5px; font-weight:bold;">ENTER PASSWORD</div>
                                <div style="display:flex; gap:5px; justify-content:center;">
                                    <input type="password" id="settingsPass" style="width:70px; padding:5px; text-align:center; border:1px solid #444; background:#000; color:#fff; border-radius:4px;" placeholder="****" maxlength="4">
                                    <button onclick="unlockSettings()" class="btn-reset" style="width:auto; margin:0; padding:5px 10px; color:#00ff88; border-color:#00ff88;">UNLOCK</button>
                                </div>
                            </div>

                            <div id="settingsControls" style="display:none;">
                                <div id="chaosModeContainer" style="margin: 0 0 10px 0; background: #220000; border: 1px dashed #ff2a2a; padding: 8px; border-radius: 6px;">
                                    <label style="color:#ff5555; font-size:11px; font-weight:800; display:flex; align-items:center; gap:8px; cursor:pointer;">
                                        <input type="checkbox" id="chaosModeToggle"> üî• SKILL TEST MODE (Bots get skills every 3s)
                                    </label>
                                </div>

                                <div style="display:flex; justify-content:flex-start; margin-bottom:10px; background:#222; padding:5px; border-radius:4px;">
                                    <label style="color:#fff; font-size:11px; font-weight:bold; display:flex; align-items:center; gap:5px;"><input type="checkbox" id="godModeToggle"> GOD MODE (Invincible + Inf. Skills)</label>
                                </div>

                                <div class="section-title" style="margin-top:0;">WORLD GENETICS</div>
                                <div class="bot-config-box">
                                    <div class="bot-row">
                                        <span>Map Size:</span>
                                        <select id="mapMult" style="background:#111; color:#ccc; border:1px solid #333; border-radius:4px; font-size:10px; font-family:'Russo One'; padding:2px;">
                                            <option value="1">x1</option>
                                            <option value="2">x2</option>
                                            <option value="3">x3</option>
                                            <option value="4">x4</option>
                                        </select>
                                    </div>
                                    <div class="bot-row">
                                        <span>Food Mass Gain:</span>
                                        <select id="foodMult" style="background:#111; color:#ccc; border:1px solid #333; border-radius:4px; font-size:10px; font-family:'Russo One'; padding:2px;">
                                            <option value="1">x1</option>
                                            <option value="2">x2</option>
                                            <option value="3">x3</option>
                                            <option value="4">x4</option>
                                        </select>
                                    </div>
                                    <div class="bot-row">
                                        <span>Base Speed:</span>
                                        <select id="speedMult" style="background:#111; color:#ccc; border:1px solid #333; border-radius:4px; font-size:10px; font-family:'Russo One'; padding:2px;">
                                            <option value="1" selected>x1 (Normal)</option>
                                            <option value="1.25">x1.25</option>
                                            <option value="1.5">x1.5</option>
                                            <option value="1.75">x1.75</option>
                                            <option value="2">x2</option>
                                        </select>
                                    </div>
                                    <div class="bot-row">
                                        <span>Virus Density:</span>
                                        <select id="virusMult" style="background:#111; color:#ccc; border:1px solid #333; border-radius:4px; font-size:10px; font-family:'Russo One'; padding:2px;">
                                            <option value="1">x1</option>
                                            <option value="2">x2</option>
                                            <option value="3">x3</option>
                                            <option value="4">x4</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="section-title">BOT CONFIGURATION</div>
                                <div class="bot-config-box">
                                    <div class="bot-row">
                                        <label style="display:flex; align-items:center; gap:5px;"><input type="checkbox" id="botsToggle" checked onchange="toggleBotOptions()"> Enable Bots</label>
                                    </div>
                                    <div id="botOptionsGroup">
                                        <div class="bot-row">
                                            <span>Count:</span>
                                            <div class="slider-container">
                                                <input type="range" id="botCountInput" min="0" max="50" value="25" oninput="document.getElementById('botCountVal').innerText = this.value">
                                                <span id="botCountVal" class="val-display">25</span>
                                            </div>
                                        </div>
                                        <div class="bot-row"><span>Respawn:</span><input type="checkbox" id="botRespawnToggle" checked></div>
                                        <div class="bot-row">
                                            <span>Bot Max Splits:</span>
                                            <select id="botSplitLimit" style="background:#111; color:#ccc; border:1px solid #333; border-radius:4px; font-size:10px; font-family:'Russo One'; padding:2px;">
                                                <option value="4">4</option>
                                                <option value="8">8</option>
                                                <option value="16" selected>16</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div style="margin-top:10px; padding-top:10px; border-top:1px solid #444;">
                                    <div class="bot-row" style="margin-bottom: 5px;">
                                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#aaa;">
                                            <input type="checkbox" id="noEnemyFX" onchange="toggleEnemyFX()"> Disable Enemy Visuals
                                        </label>
                                    </div>
                                    <div class="bot-row">
                                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#aaa;">
                                            <input type="checkbox" id="noEnemySnd" checked onchange="toggleEnemySnd()"> Disable Enemy Sounds
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </details>

                    <button class="btn-play" id="btnEnterGame" onclick="startGame()">ENTER ARENA</button>
                    <button class="btn-spectate" onclick="startSpectatorMode()">SPECTATE</button>
                    
                    <button id="qUltra" class="ultra-btn" onclick="setQuality('ultra')">
                        ‚ö° ULTRA LOW (FASTEST) ‚ö°
                    </button>
                </div>

                <div class="login-right" id="arcadeGuidePanel" style="display:none;">
                    <div style="font-family:'Russo One'; color:#ccff00; font-size:20px; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:5px;">ARCADE FEATURES</div>
                    <div class="arcade-objective">
                        <span style="color:var(--primary);">ROGUELIKE MODE:</span> EAT FOOD, VIRUSES & ENEMIES LIKE CLASSIC, BUT WITH <span style="color:#fff;">SKILLS</span>.
                        <br><br>
                        DRAFT NEW POWERS EVERY <span style="color:#fff;">30s</span> TO DOMINATE THE ARENA.
                        <br><br>
                        <span style="color:#ffd700;">$PILL ECONOMY:</span> THE <span style="color:var(--accent)">TOP 5</span> PLAYERS SPLIT THE MATCH REVENUE.
                        <br>
                        <span style="color:#888; font-size:10px; font-style:italic;">(PRACTICE FREE HERE UNLIMITED TIMES BEFORE WAGERING)</span>
                    </div>
                    <div class="skills-grid-title">SKILLS DATABASE</div>
                    <div class="skills-grid" id="skillsGrid"></div>
                    
                    <!-- TARJETA INFERIOR CON ALTURA FIJA PARA EVITAR SALTOS -->
                    <div class="skill-info-card" id="skillInfoCard">
                        <div class="card-header"><span id="cardSkillName">SELECT A SKILL</span></div>
                        <div class="card-video-box">
                            <video id="cardSkillVideo" class="card-video-player" autoplay loop muted playsinline></video>
                        </div>
                        <div id="cardSkillDesc" style="border-top: 1px solid #333; padding-top: 8px;">
                            Description area...
                        </div>
                    </div>
                    
                    <div id="secretSkinPanel" style="display:none; margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; text-align: center; animation: fadeIn 0.5s;">
                        <div style="color:#ffd700; font-family:'Russo One'; font-size:12px; margin-bottom:5px;">‚ú® SECRET SKIN UNLOCKED ‚ú®</div>
                        <input type="text" id="secretSkinInput" value="https://upload.wikimedia.org/wikipedia/en/5/5f/Original_Doge_meme.jpg" placeholder="Paste Image URL..." style="width:100%; padding: 8px; font-size:11px; background:#000; border:1px solid #ffd700; color:#fff; border-radius:4px; box-sizing:border-box;">
                        <div style="font-size:9px; color:#aaa; margin-top:3px;">Clear text to revert to colors</div>
                    </div>
                </div>

                <div class="login-right" id="classicGuidePanel" style="display:none;">
                    <div style="font-family:'Russo One'; color:#00ffaa; font-size:20px; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:5px;">CLASSIC ECONOMY</div>
                    <div class="arcade-objective" style="border-color: #00ffaa;">
                        <span style="color:#00ffaa;">PURE SKILL:</span> EAT CELLS, SPLIT (SPACE), FARM VIRUSES (GAIN MASS, GET SPLIT). NO SKILLS.
                        <br><br>
                        <span style="color:#fff;">OBJECTIVE:</span> ELIMINATE <span style="color:var(--accent)">5 PLAYERS</span> (PENTAKILL) TO MAXIMIZE PROFIT.
                        <br><br>
                        <span style="color:#ffd700;">$PILL ECONOMY:</span>
                        <ul style="margin:5px 0 10px 20px; padding:0; color:#ccc;">
                            <li>KILL 1 = BREAK EVEN (Recover Entry)</li>
                            <li>KILL 5 = <span style="color:var(--primary)">MAX ROI ($$$)</span></li>
                        </ul>
                         <span style="color:#888; font-size:10px; font-style:italic;">(PRACTICE FREE HERE UNLIMITED TIMES BEFORE WAGERING)</span>
                    </div>
                    <div class="skill-info-card" style="border-color: #00ffaa;">
                        <div class="card-header" style="color:#00ffaa;">EXIT RULES</div>
                        <div class="card-desc" style="color:#fff; font-size:11px;">
                            <div class="card-lines" style="border-color:#00ffaa;"></div>
                            YOU CAN EXIT ANYTIME, BUT WATCH OUT FOR PENALTIES.
                            <br><br>
                            <span style="color:var(--accent);">KILLS < 2:</span> 10% PENALTY FEE.
                            <br>
                            <span style="color:var(--primary);">KILLS 2+:</span> 0% PENALTY FEE (SAFE EXIT).
                            <br><br>
                            <span style="color:#ffd700; font-weight:bold;">ANTI-COMBAT LOG:</span> YOU MUST STAND STILL FOR <span style="color:#fff;">5 SECONDS</span> TO LOGOUT SAFELY.
                            <br><br>
                            <span style="color:#888;">NO TIMER. CHILL & SURVIVE.</span>
                            <div class="card-lines-bottom" style="border-color:#00ffaa;"></div>
                        </div>
                    </div>
                    
                    <!-- VIDEO CORREGIDO (../video) -->
                    <div class="split-guide-box">
                        <video id="guideVideo" class="split-video" src="../video/Split.mp4" autoplay loop muted playsinline></video>
                        <div class="split-explanation" id="guideText">
                            <span style="color:#00ffaa; font-weight:bold;">THE SPLIT (SPACE):</span>
                            <br>Essential for killing. You launch half your mass forward to eat enemies or escape. High risk, high reward. You can split into up to 16 pieces.
                        </div>
                        <button class="guide-next-arrow" type="button" onclick="nextGuide(event)">‚ùØ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="resultOverlay">
        <div class="result-box">
            <h1 style="color:var(--primary);" id="resultTitle">MATCH FINISHED</h1>
            <div class="section-title" style="text-align:center;">LEADERBOARD</div>
            <ul class="winner-list" id="winnerList"></ul>
            <div id="myResult" style="margin: 20px 0; font-family:'Russo One'; font-size:18px;"></div>
            
            <button class="btn-spectate" onclick="startSpectatorMode()" style="margin-bottom: 10px;">SPECTATE</button>
            <button class="btn-play" onclick="returnToMenu()">BACK TO MENU</button>
        </div>
    </div>

    <div id="ui">
        <div class="hud-item">ROOM: <span id="roomName" class="hud-val">5$</span></div>
        <div class="hud-item">MASS: <span id="score" class="hud-val">0</span></div>
        <div class="hud-item">ALIVE: <span id="enemyCount" class="hud-val">0</span></div>
        <div class="hud-item" id="debugHud" style="display:none;">FPS: <span id="fpsVal" style="color:#fff">0</span> | SPD: <span id="speedVal" style="color:#fff">0</span></div>
    </div>
    
    <div id="buffTable">
        <h3>ACTIVE BUFFS</h3>
        <div id="buff-list-content"></div>
    </div>

    <div id="timerDisplay">03:50</div>
    <div id="leaderboard"><h3>TOP MASS</h3><div id="lb-list"></div></div>
    
    <div id="skillChoiceOverlay">
        <div class="skill-choice-card">
            <div style="font-family:'Russo One'; color:#fff; font-size:24px;">SELECT A SKILL</div>
            <div class="skill-options" id="skillOptionsContainer"></div>
            <div class="skill-tips">PRESS [TAB] TO SWITCH - [Q] TO SELECT</div>
            <div class="timer-bar"><div class="timer-fill" id="skillTimerFill"></div></div>
        </div>
    </div>

    <div id="actionBar">
        <div class="ab-slot" id="slot1" ondblclick="removeSkill(1)" draggable="true" ondragstart="dragStart(event, 0)" ondrop="drop(event, 0)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(1, event)" onmousedown="activateSkillTouch(1, event)"><div class="skill-icon icon-empty" id="icon1"></div><div class="count-badge" id="count1" style="display:none">0</div><div class="gcd-badge" id="gcd1"></div><div class="cooldown-overlay" id="cd1"></div><div class="active-overlay" id="dur1"></div></div>
        <div class="ab-slot" id="slot2" ondblclick="removeSkill(2)" draggable="true" ondragstart="dragStart(event, 1)" ondrop="drop(event, 1)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(2, event)" onmousedown="activateSkillTouch(2, event)"><div class="skill-icon icon-empty" id="icon2"></div><div class="count-badge" id="count2" style="display:none">0</div><div class="gcd-badge" id="gcd2"></div><div class="cooldown-overlay" id="cd2"></div><div class="active-overlay" id="dur2"></div></div>
        <div class="ab-slot" id="slot3" ondblclick="removeSkill(3)" draggable="true" ondragstart="dragStart(event, 2)" ondrop="drop(event, 2)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(3, event)" onmousedown="activateSkillTouch(3, event)"><div class="skill-icon icon-empty" id="icon3"></div><div class="count-badge" id="count3" style="display:none">0</div><div class="gcd-badge" id="gcd3"></div><div class="cooldown-overlay" id="cd3"></div><div class="active-overlay" id="dur3"></div></div>
        <div class="ab-slot" id="slot4" ondblclick="removeSkill(4)" draggable="true" ondragstart="dragStart(event, 3)" ondrop="drop(event, 3)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(4, event)" onmousedown="activateSkillTouch(4, event)"><div class="skill-icon icon-empty" id="icon4"></div><div class="count-badge" id="count4" style="display:none">0</div><div class="gcd-badge" id="gcd4"></div><div class="cooldown-overlay" id="cd4"></div><div class="active-overlay" id="dur4"></div></div>
        <div class="ab-slot" id="slot5" ondblclick="removeSkill(5)" draggable="true" ondragstart="dragStart(event, 4)" ondrop="drop(event, 4)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(5, event)" onmousedown="activateSkillTouch(5, event)"><div class="skill-icon icon-empty" id="icon5"></div><div class="count-badge" id="count5" style="display:none">0</div><div class="gcd-badge" id="gcd5"></div><div class="cooldown-overlay" id="cd5"></div><div class="active-overlay" id="dur5"></div></div>
        <div class="ab-slot" id="slot6" ondblclick="removeSkill(6)" draggable="true" ondragstart="dragStart(event, 5)" ondrop="drop(event, 5)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(6, event)" onmousedown="activateSkillTouch(6, event)"><div class="skill-icon icon-empty" id="icon6"></div><div class="count-badge" id="count6" style="display:none">0</div><div class="gcd-badge" id="gcd6"></div><div class="cooldown-overlay" id="cd6"></div><div class="active-overlay" id="dur6"></div></div>
        <div class="ab-slot" id="slot7" ondblclick="removeSkill(7)" draggable="true" ondragstart="dragStart(event, 6)" ondrop="drop(event, 6)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(7, event)" onmousedown="activateSkillTouch(7, event)"><div class="skill-icon icon-empty" id="icon7"></div><div class="count-badge" id="count7" style="display:none">0</div><div class="gcd-badge" id="gcd7"></div><div class="cooldown-overlay" id="cd7"></div><div class="active-overlay" id="dur7"></div></div>
        <div class="ab-slot" id="slot8" ondblclick="removeSkill(8)" draggable="true" ondragstart="dragStart(event, 7)" ondrop="drop(event, 7)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(8, event)" onmousedown="activateSkillTouch(8, event)"><div class="skill-icon icon-empty" id="icon8"></div><div class="count-badge" id="count8" style="display:none">0</div><div class="gcd-badge" id="gcd8"></div><div class="cooldown-overlay" id="cd8"></div><div class="active-overlay" id="dur8"></div></div>
        <div class="ab-slot" id="slot9" ondblclick="removeSkill(9)" draggable="true" ondragstart="dragStart(event, 8)" ondrop="drop(event, 8)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(9, event)" onmousedown="activateSkillTouch(9, event)"><div class="skill-icon icon-empty" id="icon9"></div><div class="count-badge" id="count9" style="display:none">0</div><div class="gcd-badge" id="gcd9"></div><div class="cooldown-overlay" id="cd9"></div><div class="active-overlay" id="dur9"></div></div>
        <div class="ab-slot" id="slot10" ondblclick="removeSkill(10)" draggable="true" ondragstart="dragStart(event, 9)" ondrop="drop(event, 9)" ondragover="allowDrop(event)" ontouchstart="activateSkillTouch(10, event)" onmousedown="activateSkillTouch(10, event)"><div class="skill-icon icon-empty" id="icon10"></div><div class="count-badge" id="count10" style="display:none">0</div><div class="gcd-badge" id="gcd10"></div><div class="cooldown-overlay" id="cd10"></div><div class="active-overlay" id="dur10"></div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- TOOLTIP HTML (FLOTANTE) -->
    <div id="skill-tooltip" class="skill-tooltip">
        <div class="tooltip-img-container">
            <div id="tooltip-bg" class="tooltip-img-bg"></div>
            <img id="tooltip-icon" src="" class="tooltip-icon-main">
        </div>
        <div class="tooltip-content">
            <h4 id="tooltip-title" class="tooltip-title">NAME</h4>
            <div class="tooltip-divider"></div>
            <p id="tooltip-desc" class="tooltip-desc">Description goes here.</p>
        </div>
    </div>

<script>
    // --- PAR√ÅMETROS DE MUNDO ---
    const WORLD_CONFIG = {
        arcade: { size: 3500 },
        classic: { size: 7000 },
        foodDensity: 40, 
        virusDensity: 1
    };
    
    let worldSettings = { map: 1, food: 1, virus: 1, speed: 1 };
    const ZOOM_CONFIG = { baseScale: 1.4, exponent: 0.3, minScale: 0.05, maxScale: 2.0 };
    const UI_PARAMS = { skillSelectTop: "5%" };
    const MUSIC_VOLUME = 0.15;
    const MUSIC_START_DELAY = 1400;
    let DRAW_LOD_THRESHOLD = 3; 
    let isLowQuality = false;
    let selectedQuality = 'normal';
    let enableEnemyFX = true;
    let enableEnemySnd = true;

    // --- MOBILE VARS ---
    let isMobileInput = false;
    let joyTouchId = null;
    let joyStartX = 0, joyStartY = 0;
    let joyMoveX = 0, joyMoveY = 0;

    const SoundManager = {
        muted: false, musicMuted: false,
        lastCdTime: 0, lastKillTime: 0, lastSplitTime: 0, lastSimpleHoverTime: 0, lastFloatKillTime: 0,
        // CORREGIDO: Rutas a sonidos con ../
        sounds: { 
            alert: new Audio('../snd/alert.mp3'), cd: new Audio('../snd/cd.mp3'), death: new Audio('../snd/death.mp3'),
            hover: new Audio('../snd/hover.mp3'), iman: new Audio('../snd/iman.mp3'), kill1: new Audio('../snd/kill1.mp3'),
            kill2: new Audio('../snd/kill2.mp3'), select: new Audio('../snd/select.mp3'), shield: new Audio('../snd/shield.mp3'),
            shoot: new Audio('../snd/shoot.mp3'), simplehover: new Audio('../snd/simplehover.mp3'), simpleselect: new Audio('../snd/simpleselect.mp3'),
            split: new Audio('../snd/split.mp3'), sprint: new Audio('../snd/sprint.mp3'), timer: new Audio('../snd/timer.mp3'),
            tp: new Audio('../snd/tp.mp3'), big: new Audio('../snd/big.mp3'), little: new Audio('../snd/little.mp3'),
            virus: new Audio('../snd/virus.mp3'), floatkill: new Audio('../snd/floatkill.mp3')
        },
        music: new Audio('../snd/music.mp3'), startTimer: null, 
        init: function() {
            if(localStorage.getItem('pillwars_muted') === 'true') { this.muted = true; document.getElementById('soundToggle').classList.add('muted'); }
            this.music.loop = true; this.music.volume = MUSIC_VOLUME;
            if(localStorage.getItem('pillwars_music_muted') === 'true') { this.musicMuted = true; this.music.muted = true; document.getElementById('musicToggle').classList.add('muted'); } 
            else { document.getElementById('musicToggle').classList.remove('muted'); }
            for(let key in this.sounds) { this.sounds[key].load(); } this.music.load();
        },
        toggleSFX: function() { 
            this.muted = !this.muted; const btn = document.getElementById('soundToggle'); 
            if (this.muted) { btn.classList.add('muted'); localStorage.setItem('pillwars_muted', 'true'); } 
            else { btn.classList.remove('muted'); localStorage.setItem('pillwars_muted', 'false'); } 
        },
        toggleMusic: function() { 
            this.musicMuted = !this.musicMuted; this.music.muted = this.musicMuted; const btn = document.getElementById('musicToggle'); 
            if (this.musicMuted) { btn.classList.add('muted'); localStorage.setItem('pillwars_music_muted', 'true'); } 
            else { btn.classList.remove('muted'); localStorage.setItem('pillwars_music_muted', 'false'); } 
            if(!this.musicMuted && gameRunning && !isSpectating && !this.startTimer) { this.music.play().catch(e=>{}); } 
        },
        setVolume: function(val) { this.music.volume = parseFloat(val); },
        play: function(name, pos = null) { 
            if(this.muted || !this.sounds[name]) return; 
            if (pos && gameRunning && !isSpectating) {
                let es = getViewScale(); let vW = width / es; let vH = height / es; let margin = 100;
                if (pos.x < camera.x - vW/2 - margin || pos.x > camera.x + vW/2 + margin || pos.y < camera.y - vH/2 - margin || pos.y > camera.y + vH/2 + margin) { return; }
            }
            if (name === 'cd') { if (Date.now() - this.lastCdTime < 700) return; this.lastCdTime = Date.now(); }
            const s = this.sounds[name]; s.currentTime = 0; s.play().catch(e => {}); 
        },
        stop: function(name) { if (this.sounds[name]) { this.sounds[name].pause(); this.sounds[name].currentTime = 0; } },
        playSimpleHover: function() { if (Date.now() - this.lastSimpleHoverTime < 100) return; this.lastSimpleHoverTime = Date.now(); this.play('simplehover'); },
        playKill: function() { const now = Date.now(); if (now - this.lastKillTime < 150) return; this.lastKillTime = now; const snd = Math.random() < 0.5 ? 'kill1' : 'kill2'; this.play(snd); },
        playFloatKill: function() { const now = Date.now(); if (now - this.lastFloatKillTime < 200) return; this.lastFloatKillTime = now; this.play('floatkill'); },
        playSplit: function() { const now = Date.now(); if (now - this.lastSplitTime < 150) return; this.lastSplitTime = now; this.play('split'); },
        playMusic: function() { if(!this.musicMuted) { if(this.startTimer) clearTimeout(this.startTimer); this.startTimer = setTimeout(() => { this.music.play().catch(e=>{}); this.startTimer = null; }, MUSIC_START_DELAY); } },
        stopMusic: function() { if(this.startTimer) { clearTimeout(this.startTimer); this.startTimer = null; } this.music.pause(); this.music.currentTime = 0; }
    };

    // --- OPTIMIZATION CLASSES ---
    class ObjectPool {
        constructor(createFn) { this.createFn = createFn; this.pool = []; }
        get() { return this.pool.length > 0 ? this.pool.pop() : this.createFn(); }
        free(obj) { this.pool.push(obj); }
    }
    const createFood = () => ({ x: 0, y: 0, r: 0, c1: '#fff', c2: '#fff', angle: 0, spikes: [] });
    const createVirus = () => ({ x: 0, y: 0, r: 0, vx: 0, vy: 0, hits: 0, damaged: false, animTime: 0, spots: [] });
    const foodPool = new ObjectPool(createFood);
    const virusPool = new ObjectPool(createVirus);

    class SpatialGrid {
        constructor(cellSize) { this.cellSize = cellSize; this.buckets = new Map(); }
        clear() { this.buckets.clear(); }
        key(x, y) { return `${Math.floor(x/this.cellSize)},${Math.floor(y/this.cellSize)}`; }
        insert(obj) {
            const k = this.key(obj.x, obj.y);
            if(!this.buckets.has(k)) this.buckets.set(k, []);
            this.buckets.get(k).push(obj);
        }
        query(x, y) {
            const keys = [];
            const cx = Math.floor(x / this.cellSize);
            const cy = Math.floor(y / this.cellSize);
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    keys.push(`${cx+i},${cy+j}`);
                }
            }
            let results = [];
            for(let k of keys) {
                const b = this.buckets.get(k);
                if(b) results = results.concat(b);
            }
            return results;
        }
    }
    const foodGrid = new SpatialGrid(150);

    function enableAudioContext() { document.removeEventListener('click', enableAudioContext); document.removeEventListener('keydown', enableAudioContext); document.removeEventListener('touchstart', enableAudioContext); }
    document.addEventListener('click', enableAudioContext); document.addEventListener('keydown', enableAudioContext); document.addEventListener('touchstart', enableAudioContext);
    function toggleAudio() { SoundManager.toggleSFX(); }
    function toggleMusic() { SoundManager.toggleMusic(); }
    function toggleEnemyFX() { enableEnemyFX = !document.getElementById('noEnemyFX').checked; }
    function toggleEnemySnd() { enableEnemySnd = !document.getElementById('noEnemySnd').checked; }
    
    function unlockSettings() {
        const pass = document.getElementById('settingsPass').value;
        if(pass === "1234") { SoundManager.play('simpleselect'); document.getElementById('settingsLock').style.display = 'none'; document.getElementById('settingsControls').style.display = 'block'; } 
        else { SoundManager.play('little'); document.getElementById('settingsPass').value = ""; alert("WRONG PASSWORD"); }
    }

    function setQuality(mode) {
        SoundManager.play('simpleselect'); selectedQuality = mode;
        document.querySelectorAll('.q-btn, .ultra-btn').forEach(b => b.classList.remove('selected'));
        if(mode === 'ultra') document.getElementById('qUltra').classList.add('selected');
        else if(mode === 'high') document.getElementById('qHigh').classList.add('selected');
        else if(mode === 'normal') document.getElementById('qNormal').classList.add('selected');
        else if(mode === 'low') document.getElementById('qLow').classList.add('selected');
    }

    function setTheme(mode) {
        const root = document.documentElement;
        if (mode === 'white') { root.style.setProperty('--bg-color', '#f0f0f0'); root.style.setProperty('--grid-line', 'rgba(0, 0, 0, 0.05)'); } 
        else if (mode === 'grey') { root.style.setProperty('--bg-color', '#2a2a2a'); root.style.setProperty('--grid-line', 'rgba(255, 255, 255, 0.03)'); } 
        else { root.style.setProperty('--bg-color', '#050505'); root.style.setProperty('--grid-line', 'rgba(255, 255, 255, 0.03)'); }
    }

    const baseTime = 15000, massFactor = 0.225, SPLIT_COOLDOWN_MS = 1000;
    const SKILL_PARAMS = { clonCost: 2000, clonCooldown: 1000, clonSpeed: 40, shootCost: 2500, shootBulletSpeed: 20, shootVirusSpeed: 20, shootDmgThreshold: 15000, sprintSpeedMult: 1.5, sprintDuration: 10000, magnetForce: 3, magnetRange: 200, magnetDuration: 8000, shieldDuration: 3000, bigMin: 5000, bigMax: 12000 };
    const VIRUS_RADIUS = 70, VIRUS_GAIN_LOW = 5000, VIRUS_GAIN_HIGH = 10000, VIRUS_GAIN_THRESHOLD = 100000;  
    
    let globalCDTimer = 0, fpsTimer = 0, frameCount = 0, GLOBAL_CD_MS = 1000;
    const SHOW_MASS_AS_SCORE = true, AUTO_SPLIT_LEVEL_1 = 200000, AUTO_SPLIT_LEVEL_2 = 300000;
    const BASE_WIDTH = 1920, BASE_HEIGHT = 1080;
    let roomStates = {}, roomTimers = {}, MAP_SIZE = 3500; 
    const INITIAL_RADIUS = 10, MAX_CELLS = 16, VELOC_BASE = 1.4, SPLIT_FORCE = 65, PILL_RATIO = 2.0; 
    let MAX_BOT_CELLS = 16, GAME_DURATION_MS = 3 * 60 * 1000 + 50 * 1000; 
    let currentKillStreak = 0, logoutTimer = null, isLoggingOut = false, isSpecDragging = false, lastSpecX = 0, lastSpecY = 0;

    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const els = { modeScreen: document.getElementById('modeScreen'), loginOverlay: document.getElementById('loginOverlay'), selectedModeTitle: document.getElementById('selectedModeTitle'), playerNameInput: document.getElementById('playerNameInput'), botsToggle: document.getElementById('botsToggle'), botCountInput: document.getElementById('botCountInput'), botRespawnToggle: document.getElementById('botRespawnToggle'), godModeToggle: document.getElementById('godModeToggle'), enemyCount: document.getElementById('enemyCount'), score: document.getElementById('score'), room: document.getElementById('roomName'), lbList: document.getElementById('lb-list'), timer: document.getElementById('timerDisplay'), result: document.getElementById('resultOverlay'), resultTitle: document.getElementById('resultTitle'), gameOver: document.getElementById('gameOverMsg'), winnerList: document.getElementById('winnerList'), myResult: document.getElementById('myResult'), debugHud: document.getElementById('debugHud'), fpsVal: document.getElementById('fpsVal'), speedVal: document.getElementById('speedVal'), skillOverlay: document.getElementById('skillChoiceOverlay'), skillOpts: document.getElementById('skillOptionsContainer'), skillTimer: document.getElementById('skillTimerFill'), actionBar: document.getElementById('actionBar'), buffTable: document.getElementById('buffTable'), buffList: document.getElementById('buff-list-content') };

    let currentGameMode = 'classic', currentServer = "5$", width, height, gameRunning = false, isGodMode = false, isSpectating = false; 
    let lastTapTime = 0, lastSplitTime = 0, splitMilestones = { level1: false, level2: false }, lastFrameTime = performance.now(), timeScale = 1.0;
    let camera = { x: 0, y: 0, scale: 0.8 }, mouse = { x: 0, y: 0 }, inputMode = 'MOUSE', keys = { w: false, a: false, s: false, d: false, f: false }, botConfig = { enabled: true, count: 25, respawn: true };
    let foods = [], viruses = [], enemies = [], explosions = [], ejectedMasses = [], projectiles = [], player = { name: "Player", id: "me", cells: [] };

    let skills = { 1: { id: 1, name: 'CLON', icon: 'icon-clon', uses: 4, active: 0, maxActive: SKILL_PARAMS.clonCooldown }, 2: { id: 2, name: 'SHOOT', icon: 'icon-shot', uses: 4, active: 0, maxActive: 15 }, 3: { id: 3, name: 'SPRINT', icon: 'icon-sprint', uses: 1, active: 0, maxActive: SKILL_PARAMS.sprintDuration }, 4: { id: 4, name: 'TELEPORT', icon: 'icon-tp', uses: 1, active: 0, maxActive: 20 }, 5: { id: 5, name: 'MAGNET', icon: 'icon-magnet', uses: 1, active: 0, maxActive: SKILL_PARAMS.magnetDuration }, 6: { id: 6, name: 'SHIELD', icon: 'icon-shield', uses: 1, active: 0, maxActive: SKILL_PARAMS.shieldDuration }, 7: { id: 7, name: 'PLUS', icon: 'icon-big', uses: 1, active: 0, maxActive: 20 }, 8: { id: 8, name: 'GAMBLE', icon: 'icon-random', uses: 1, active: 0, maxActive: 20 } };
    let playerSkills = [], nextSkillPickTime = 0, isPickingSkill = false, pickTimer = 0, massMilestoneReached = false, uiSlots = [], uiCounts = [], uiOverlays = [], uiOverlaysActive = [], uiIcons = [], uiGcds = [];
    const BOT_NAMES = ["ETH", "USA", "Doge", "NASA", "Icefox", "Bandit", "Mars", "BTC", "PUMP", "Noob"], COLORS = ['#F44336', '#9C27B0', '#3F51B5', '#03A9F4', '#009688', '#8BC34A', '#FFC107', '#FF5722'];
    
    let skillChoiceIndex = 0, isHoveringUI = false, ignoreNextHover = false, lastHoveredMode = null;
    let currentGuideIndex = 0;
    // CORREGIDO: Rutas a videos con ../
    const guideSlides = [
        { video: '../video/Split.mp4', title: 'THE SPLIT (SPACE):', desc: 'Essential for killing. You launch half your mass forward to eat enemies. High risk, high reward. You can split into up to 16 pieces.' },
        { video: '../video/Virus.mp4', title: 'VIRUS FARMING:', desc: 'Touching a virus splits you into three pieces, but grants a mass bonus. You can use viruses to grow faster, at the risk of becoming too divided. and more vulnerable.' },
        { video: '../video/Viral.mp4', title: 'COMBAT MECHANICS:', desc: 'Use SHOOT (1) to hit viruses from a distance. The first shot corrupts a virus, turning it purple. Shoot it again to trigger an explosive projectile. that damages nearby players. Keep moving to avoid incoming fire.' }
    ];

    function nextGuide(e) {
        if(e) { e.preventDefault(); e.stopPropagation(); }
        SoundManager.play('simpleselect');
        currentGuideIndex++; if(currentGuideIndex >= guideSlides.length) currentGuideIndex = 0;
        updateGuideUI();
    }

    function updateGuideUI() {
        const slide = guideSlides[currentGuideIndex];
        const videoEl = document.getElementById('guideVideo');
        const textEl = document.getElementById('guideText');
        videoEl.src = slide.video; videoEl.onloadeddata = () => { videoEl.play().catch(e => {}); };
        textEl.innerHTML = `<span style="color:#00ffaa; font-weight:bold;">${slide.title}</span><br>${slide.desc}`;
    }

    // CORREGIDO: Rutas a videos e im√°genes con ../
    const SKILL_DESCRIPTIONS = {
        1: { name: "CLON", desc: "THE FARMER. Shoots a mass projectile. IMPORTANT: If it hits a VIRUS, it clones it and grants you a NEW SKILL card. Cooldown: 1s.", video: "../video/Clon.mp4", icon: "../img/clon.png" },
        2: { name: "SHOOT", desc: "OFFENSIVE. Fires mass projectiles to damage enemies or push viruses. Does not grant skills. Cost: 2500 Mass.", video: "../video/Shoot.mp4", icon: "../img/shoot.png" },
        3: { name: "SPRINT", desc: "MOBILITY. Boosts movement speed by 50% for 10 seconds. Great for chasing or escaping. Passive effect: Gold aura.", video: "../video/Sprint.mp4", icon: "../img/sprint.png" },
        4: { name: "TELEPORT", desc: "EVASION. Instantly teleports all your cells to a random safe location near your center. Use to dodge attacks.", video: "../video/Tp.mp4", icon: "../img/tp.png" },
        5: { name: "MAGNET", desc: "UTILITY. Automatically pulls nearby food pellets towards your cells for 8 seconds. Radius: 200px.", video: "../video/Magnet.mp4", icon: "../img/iman.png" },
        6: { name: "SHIELD", desc: "DEFENSE. Grants total immunity to viruses and being eaten by larger players for 3 seconds. Visual: Purple forcefield.", video: "../video/Inmune.mp4", icon: "../img/inmune.png" },
        7: { name: "PLUS", desc: "GROWTH. Instantly grants a large amount of mass (5k - 12k) distributed among your cells.", video: "../video/Plus.mp4", icon: "../img/big.png" },
        8: { name: "GAMBLE", desc: "RISK. 50% chance to gain 15,000 Mass (JACKPOT). 50% chance to lose 5,000 Mass. Do you feel lucky?", video: "../video/Gamble.mp4", icon: "../img/random.png" }
    };

    const TooltipManager = {
        dom: {
            tooltip: document.getElementById('skill-tooltip'),
            title: document.getElementById('tooltip-title'),
            desc: document.getElementById('tooltip-desc'),
            icon: document.getElementById('tooltip-icon'),
            bg: document.getElementById('tooltip-bg')
        },
        show: function(e, id) {
            const data = SKILL_DESCRIPTIONS[id];
            if (!data) return;

            this.dom.title.innerText = data.name;
            this.dom.desc.innerText = data.desc;
            this.dom.icon.src = data.icon;
            this.dom.bg.style.backgroundImage = `url('${data.icon}')`;

            const card = e.currentTarget;
            const rect = card.getBoundingClientRect();
            const toolTipWidth = 250; 
            const toolTipHeight = 320; 

            let leftPos = rect.left - toolTipWidth - 20; 
            let topPos = rect.top - 50;

            if (leftPos < 0) leftPos = rect.right + 20;
            
            this.dom.tooltip.style.left = leftPos + 'px';
            this.dom.tooltip.style.top = topPos + 'px';
            this.dom.tooltip.style.display = 'flex';
        },
        hide: function() {
            this.dom.tooltip.style.display = 'none';
        }
    };

    function initArcadeGuide() {
        const grid = document.getElementById('skillsGrid');
        grid.innerHTML = '';
        for(let i=1; i<=8; i++) {
            let s = skills[i];
            let div = document.createElement('div');
            div.className = `grid-skill-icon ${s.icon}`;
            div.style.backgroundColor = '#111'; 
            
            div.onmouseenter = function(e) { TooltipManager.show(e, i); };
            div.onmouseleave = function() { TooltipManager.hide(); };

            div.onclick = function() { selectGuideSkill(i, div); };
            grid.appendChild(div);
        }
        if(grid.children.length > 0) {
            selectGuideSkill(1, grid.children[0], true);
        }
    }

    let skinCodeSequence = [];
    const TARGET_SEQUENCE = [1, 4, 1, 2, 7, 7, 7];

    function selectGuideSkill(id, element, silent = false) {
        document.querySelectorAll('.grid-skill-icon').forEach(el => el.classList.remove('selected'));
        if(element) element.classList.add('selected');
        
        if(!silent) SoundManager.play('simpleselect');
        
        if (!silent) {
            skinCodeSequence.push(id);
            if(skinCodeSequence.length > TARGET_SEQUENCE.length) skinCodeSequence.shift();
            if(JSON.stringify(skinCodeSequence) === JSON.stringify(TARGET_SEQUENCE)) {
                SoundManager.play('alert');
                document.getElementById('secretSkinPanel').style.display = 'block';
            }
        }

        const data = SKILL_DESCRIPTIONS[id];
        if (!data) return;
        
        document.getElementById('cardSkillName').innerText = data.name;
        const descEl = document.getElementById('cardSkillDesc');
        if(descEl) descEl.innerText = data.desc;
        
        const vidPlayer = document.getElementById('cardSkillVideo');
        
        const currentSrc = vidPlayer.getAttribute('src');
        if (!currentSrc || currentSrc.indexOf(data.video) === -1) {
            vidPlayer.src = data.video;
            vidPlayer.play().catch(e=>{});
        }
    }

    class FloatingText {
        constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 1.0; this.vy = -2.0; }
        update() { this.life -= 0.015; this.y += this.vy * timeScale; }
        draw(ctx) {
            let es = getViewScale(); let screenX = (this.x - camera.x) * es + width/2; let screenY = (this.y - camera.y) * es + height/2;
            if (screenX < -200 || screenX > width + 200 || screenY < -200 || screenY > height + 200) return;
            ctx.save(); ctx.translate(this.x, this.y); ctx.scale(1/es, 1/es); ctx.globalAlpha = Math.max(0, this.life); ctx.font = "900 32px 'Russo One'"; ctx.textAlign = "center";
            ctx.lineWidth = 5; ctx.strokeStyle = "#000"; ctx.strokeText(this.text, 0, 0); ctx.fillStyle = this.color; ctx.fillText(this.text, 0, 0); ctx.restore();
        }
    }
    let floatingTexts = [];

    class FixedUIText {
        constructor(text, color) { this.text = text; this.color = color; this.life = 2.0; this.yOffset = 0; }
        update() { this.life -= 0.02; this.yOffset -= 0.5 * timeScale; }
        draw(ctx) {
            ctx.save(); ctx.globalAlpha = Math.min(1, this.life); ctx.font = "bold 20px 'Russo One'"; ctx.textAlign = "center"; ctx.lineWidth = 3; ctx.strokeStyle = "#000";
            let posX = width / 2; let posY = height * 0.4 + this.yOffset; ctx.strokeText(this.text, posX, posY); ctx.fillStyle = this.color; ctx.fillText(this.text, posX, posY); ctx.restore();
        }
    }
    let uiTexts = [];

    function spawnFloatingText(text, color, isWorld = false) {
        if (isWorld) { if(player.cells.length > 0) { let c = player.cells.reduce((prev, curr) => prev.r > curr.r ? prev : curr); floatingTexts.push(new FloatingText(c.x, c.y, text, color)); } } 
        else { uiTexts.push(new FixedUIText(text, color)); }
    }

    if (!CanvasRenderingContext2D.prototype.roundRect) { CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) { if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2; this.beginPath(); this.moveTo(x + r, y); this.arcTo(x + w, y, x + w, y + h, r); this.arcTo(x + w, y + h, x, y + h, r); this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r); this.closePath(); return this; }; }
    const uuid = () => Math.random().toString(36).substr(2, 9), getEllipticalDist = (c1, c2) => { let dx = c1.x - c2.x, dy = c1.y - c2.y, k = 0.7071; let rx = dx*k - dy*k, ry = (dx*k + dy*k) / PILL_RATIO; return Math.sqrt(rx*rx + ry*ry); };

    function getViewScale() { let scaleX = width / BASE_WIDTH; let scaleY = height / BASE_HEIGHT; return camera.scale * Math.max(scaleX, scaleY); }
    function getRandomColor() { return COLORS[Math.floor(Math.random() * COLORS.length)]; }

    function grantBotSkill(bot) {
        let siblings = enemies.filter(e => e.id === bot.id);
        let pool = [3, 4, 5, 6, 7, 7, 8, 8]; 
        let skillId = pool[Math.floor(Math.random() * pool.length)];
        siblings.forEach(s => { s.botSkills.push(skillId); });
    }

    function botEmitProjectile(bot, type, cost) {
        if (bot.mass - cost < 314) return;
        bot.r = Math.sqrt((bot.mass - cost) / (Math.PI * PILL_RATIO));
        let angle = Math.atan2(bot.vy, bot.vx); if (Math.abs(bot.vx) < 0.1 && Math.abs(bot.vy) < 0.1) angle = Math.random() * Math.PI * 2;
        let spawnDist = bot.r * 1.5 + 25, spd = (type==='shoot')?20:40, r = (type==='shoot')?12:16;
        let obj = { x: bot.x + Math.cos(angle) * spawnDist, y: bot.y + Math.sin(angle) * spawnDist, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd, r: r, angle: Math.random()*Math.PI, type: type, c1: bot.colorBot, c2: bot.colorTop }; 
        if(type==='shoot') { obj.c1 = '#ff2a2a'; obj.c2 = '#fff'; }
        ejectedMasses.push(obj);
        if (enableEnemySnd) SoundManager.play('shoot', {x: bot.x, y: bot.y});
    }

    class Cell {
        constructor(x, y, r, cBot, cTop, name, isBot = false, skinUrl = null, id = null) { 
            this.x = x; this.y = y; this.r = r; this.colorBot = cBot; this.colorTop = cTop; 
            this.name = name; this.isBot = isBot; this.id = id || uuid(); 
            this.skin = (skinUrl && skinUrl.length > 5) ? new Image() : null; if(this.skin) this.skin.src = skinUrl; 
            this.particles = []; this.vx = 0; this.vy = 0; this.boostX = 0; this.boostY = 0;
            this.bornTime = Date.now(); this.changeDirTimer = 0; this.targetX = x; this.targetY = y; 
            this.immuneTime = 0; this.groupMaxR = r; this.flashTime = 0; this.flashColor = null; 
            this.lastSplitTime = 0; 
            this.tpPhase = 0; this.tpTimer = 0; this.tpDest = {x:0, y:0};
            if (this.isBot) { this.botSkills = []; this.botGcd = 0; this.botNextSkillTime = 0; this.massMilestoneMet = false; this.magnetTime = 0; this.sprintTime = 0; this.shouldSplit = false; }
        }
        get mass() { return Math.PI * this.r * (this.r * PILL_RATIO); }
        get mergeTime() { return baseTime + (this.mass * massFactor); }
        get canMerge() { return (Date.now() - this.bornTime) > this.mergeTime; }
        
        update(delta) {
            if (this.tpPhase > 0) {
                this.tpTimer -= delta;
                if (this.tpPhase === 1) { if (this.tpTimer <= 0) { this.x = this.tpDest.x; this.y = this.tpDest.y; this.targetX = this.x; this.targetY = this.y; this.tpPhase = 2; this.tpTimer = 500; this.immuneTime = 500; } } 
                else if (this.tpPhase === 2) { if (this.tpTimer <= 0) { this.tpPhase = 0; } }
                this.vx = 0; this.vy = 0; this.boostX = 0; this.boostY = 0; return;
            }
            if (this.immuneTime > 0) { this.immuneTime -= delta; if (this.immuneTime < 0) this.immuneTime = 0; }
            if (this.flashTime > 0) { this.flashTime -= delta; if(this.flashTime < 0) this.flashTime = 0; }
            if (this.isBot) { if (this.magnetTime > 0) { this.magnetTime -= delta; if(this.magnetTime < 0) this.magnetTime = 0; } if (this.sprintTime > 0) { this.sprintTime -= delta; if(this.sprintTime < 0) this.sprintTime = 0; } }

            for(let i=this.particles.length-1; i>=0; i--) { let p = this.particles[i]; p.life -= 0.05 * timeScale; p.y += p.vy * timeScale; p.x += p.vx * timeScale; if(p.life <= 0) this.particles.splice(i, 1); }
            let effectiveR = Math.max(this.groupMaxR, this.r, 20);
            let baseSpeed = VELOC_BASE * (worldSettings.speed || 1);
            let speedMult = baseSpeed * 10.0 * Math.pow(effectiveR, -0.46);
            let isSprinting = false;
            
            if (!this.isBot && (currentGameMode === 'arcade' || currentGameMode === 'skills')) { if(playerSkills.some(s => s && s.id === 3 && skills[3].active > 0)) { speedMult *= SKILL_PARAMS.sprintSpeedMult; isSprinting = true; } }
            if (this.isBot && this.sprintTime > 0) { speedMult *= SKILL_PARAMS.sprintSpeedMult; isSprinting = true; }

            if (isSprinting && Math.random() < 0.2) this.spawnParticles('BOLT');
            if(speedMult < 0.2) speedMult = 0.2; 
            if (Math.abs(this.boostX) > 0.1 || Math.abs(this.boostY) > 0.1) { this.boostX *= Math.pow(0.9, timeScale); this.boostY *= Math.pow(0.9, timeScale); } else { this.boostX = 0; this.boostY = 0; }
            let dx = 0, dy = 0;
            if (!this.isBot && !isSpectating) { 
                if (isLoggingOut) { dx = 0; dy = 0; } 
                else if (inputMode === 'MOUSE') { let es = getViewScale(); dx = ((mouse.x - width/2) / es + camera.x) - this.x; dy = ((mouse.y - height/2) / es + camera.y) - this.y; } 
                else { 
                    let avgX = 0, avgY = 0, count = 0; if (!this.isBot && player.cells.length > 0) { player.cells.forEach(c => { avgX += c.x; avgY += c.y; count++; }); if(count > 0) { avgX /= count; avgY /= count; } let dirX = 0, dirY = 0; if (keys.a) dirX -= 1; if (keys.d) dirX += 1; if (keys.w) dirY -= 1; if (keys.s) dirY += 1; let dist = 1000; let targetX = avgX + (dirX * dist); let targetY = avgY + (dirY * dist); dx = targetX - this.x; dy = targetY - this.y; }
                } 
            } else if (this.isBot) { this.botAI(delta); dx = this.targetX - this.x; dy = this.targetY - this.y; }
            let dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0.001) { this.vx = (dx / dist) * speedMult; this.vy = (dy / dist) * speedMult; } else { this.vx = 0; this.vy = 0; }
            let maxAllowed = speedMult * 1.2, currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); if (currentSpeed > maxAllowed) { let ratio = maxAllowed / currentSpeed; this.vx *= ratio; this.vy *= ratio; }
            this.x += (this.vx + this.boostX) * timeScale; this.y += (this.vy + this.boostY) * timeScale;
            let margin = (this.r + (this.r * PILL_RATIO)) * 0.7071, limit = MAP_SIZE - margin; this.x = Math.max(Math.min(this.x, limit), -limit); this.y = Math.max(Math.min(this.y, limit), -limit);
        }

        spawnParticles(type) {
            if (this.isBot && !enableEnemyFX) return;
            let count = (type === 'BOLT') ? 1 : (Math.floor(Math.random() * 3) + 4); let scale = (type === 'BOLT') ? Math.max(1, this.r / 15) : 1; 
            for(let i=0; i<count; i++) {
                let angle = Math.random() * Math.PI * 2; let offset = this.r * Math.random(); let vy = (type === 'PLUS') ? -(Math.random()*2 + 1) : (Math.random()*2 + 1);
                if (type === 'BOLT') { this.particles.push({ x: Math.cos(angle) * this.r, y: Math.sin(angle) * this.r, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, life: 0.8, type: type, rot: Math.random() * 360, scale: scale }); } 
                else { this.particles.push({ x: Math.cos(angle) * offset, y: Math.sin(angle) * offset, vx: (Math.random() - 0.5) * 2, vy: vy, life: 1.0, type: type, rot: Math.random() * 360, scale: 1 }); }
            }
        }

        botAI(delta) { 
            if (this.botGcd > 0) this.botGcd -= delta;
            let siblings = enemies.filter(e => e.id === this.id).sort((a,b) => b.mass - a.mass);
            let leader = siblings[0]; 
            if (this !== leader) { this.targetX = leader.targetX; this.targetY = leader.targetY; return; }
            
            if (currentGameMode === 'skills') {
                if (Date.now() > this.botNextSkillTime) { let nextTime = Date.now() + 3000; siblings.forEach(s => s.botNextSkillTime = nextTime); grantBotSkill(this); }
            } else if (currentGameMode === 'arcade') {
                if (!this.massMilestoneMet && this.mass >= 3500) { let nextTime = Date.now() + 30000; siblings.forEach(s => { s.massMilestoneMet = true; s.botNextSkillTime = nextTime; }); grantBotSkill(this); }
                if (this.massMilestoneMet && Date.now() > this.botNextSkillTime) { let nextTime = Date.now() + 30000; siblings.forEach(s => s.botNextSkillTime = nextTime); grantBotSkill(this); }
            }

            if (this.botSkills.length > 0 && this.botGcd <= 0) {
                let priorityIdx = this.botSkills.findIndex(id => id === 7 || id === 8); let skillToUse = -1;
                if (priorityIdx !== -1) { skillToUse = this.botSkills[priorityIdx]; } 
                else { let chance = (currentGameMode === 'skills') ? 0.1 : 0.02; if (this.botSkills.includes(3) && Math.random() < 0.05) skillToUse = 3; else if (Math.random() < chance) skillToUse = this.botSkills[0]; }
                if (skillToUse !== -1) { this.executeBotSkill(skillToUse); siblings.forEach(s => { let idx = s.botSkills.indexOf(skillToUse); if(idx !== -1) s.botSkills.splice(idx, 1); s.botGcd = 1000; }); }
            }

            this.changeDirTimer--; if (Math.abs(this.x) > MAP_SIZE - 200 || Math.abs(this.y) > MAP_SIZE - 200) { this.targetX = 0; this.targetY = 0; return; } 
            let flee = false, visionRange = 750, targetPrey = null; 
            let allEntities = [...enemies, ...player.cells];
            
            allEntities.forEach(e => {
                if (e.id === this.id) return; 
                let d = getEllipticalDist(this, e);
                if (e.mass > this.mass * 1.25 && d < visionRange + this.r) { this.targetX = this.x - (e.x - this.x); this.targetY = this.y - (e.y - this.y); flee = true; }
                else if (this.mass > e.mass * 1.25 && d < visionRange) { if (!targetPrey || d < targetPrey.dist) { targetPrey = { cell: e, dist: d }; } }
            });

            if (!flee && targetPrey) { let isHiding = isHiddenInVirus(targetPrey.cell); if (!isHiding) { this.targetX = targetPrey.cell.x; this.targetY = targetPrey.cell.y; flee = true; } }
            if(!flee) viruses.forEach(v => { if (this.r > v.r && getEllipticalDist(this, v) < this.r + 120) flee = true; }); 
            
            if (targetPrey && this.r > 45) { 
                let mySplitMass = (this.mass / 2); let preyMass = targetPrey.cell.mass; let boostRange = 400 + this.r; let attackRange = boostRange * 0.66;
                if (mySplitMass > preyMass * 1.5 && targetPrey.dist < attackRange && (Date.now() - this.lastSplitTime > 8000)) {
                    let currentCount = siblings.length;
                    siblings.forEach(s => {
                        if (currentCount >= MAX_BOT_CELLS) return; 
                        if ( (s.mass/2) > preyMass * 1.5 ) { performSplit(s, Math.atan2(targetPrey.cell.y - s.y, targetPrey.cell.x - s.x)); s.lastSplitTime = Date.now(); currentCount++; }
                    });
                }
            }
            if (flee) return; if (this.changeDirTimer <= 0) { this.targetX = Math.random() * (MAP_SIZE*1.8) - MAP_SIZE*0.9; this.targetY = Math.random() * (MAP_SIZE*1.8) - MAP_SIZE*0.9; this.changeDirTimer = Math.random() * 80 + 40; } 
        }

        executeBotSkill(id) {
            let siblings = enemies.filter(e => e.id === this.id); let leader = this;
            const showText = (txt, col) => { if (player.cells.length > 0 && getEllipticalDist(leader, player.cells[0]) < 1500 && enableEnemyFX) { floatingTexts.push(new FloatingText(leader.x, leader.y, txt, col)); } };
            
            if (id === 3) { siblings.forEach(s => { s.sprintTime = SKILL_PARAMS.sprintDuration; s.boostX += s.vx * 2; s.boostY += s.vy * 2; if(enableEnemyFX) s.spawnParticles('BOLT'); }); } 
            else if (id === 4) { let limit = MAP_SIZE - 300; let centerX = Math.random()*(limit*2)-limit; let centerY = Math.random()*(limit*2)-limit; siblings.forEach(s => { s.tpPhase = 1; s.tpTimer = 500; s.tpDest = { x: centerX + (Math.random()*100-50), y: centerY + (Math.random()*100-50) }; }); }
            else if (id === 5) { siblings.forEach(s => s.magnetTime = SKILL_PARAMS.magnetDuration); showText("MAGNET", "#A020F0"); }
            else if (id === 6) { siblings.forEach(s => s.immuneTime = SKILL_PARAMS.shieldDuration); showText("SHIELD", "#FFD700"); }
            else if (id === 7) { let totalGain = Math.floor(Math.random()*(SKILL_PARAMS.bigMax-SKILL_PARAMS.bigMin+1))+SKILL_PARAMS.bigMin; let gainPerCell = totalGain / siblings.length; siblings.forEach(s => { s.r = Math.sqrt((s.mass + gainPerCell) / (Math.PI * PILL_RATIO)); if(enableEnemyFX) { s.flashColor = '#00ff00'; s.flashTime = 1000; s.spawnParticles('PLUS'); } }); showText("MASS UP", "#00FF00"); }
            else if (id === 8) { let totalVal = (Math.random() < 0.5) ? -5000 : 15000; let valPerCell = totalVal / siblings.length; siblings.forEach(s => { let newMass = s.mass + valPerCell; if (newMass < 314) newMass = 314; s.r = Math.sqrt(newMass / (Math.PI * PILL_RATIO)); if(enableEnemyFX) { s.flashColor = (totalVal >= 0) ? '#00ff00' : '#ff0000'; s.flashTime = 1000; s.spawnParticles(totalVal >= 0 ? 'PLUS' : 'MINUS'); } }); showText(totalVal >= 0 ? "JACKPOT!" : "FAIL!", totalVal >= 0 ? "#00FF00" : "#FF0000"); }
        }
        
        draw() { 
            let isSprinting = (!this.isBot && (currentGameMode === 'arcade' || currentGameMode === 'skills') && playerSkills.some(s => s && s.id === 3 && skills[3].active > 0)); if (this.isBot && this.sprintTime > 0) isSprinting = true;
            let alpha = 1; if (this.tpPhase === 1) alpha = Math.max(0, this.tpTimer / 500); else if (this.tpPhase === 2) alpha = Math.max(0, 1 - (this.tpTimer / 500));
            ctx.save(); ctx.globalAlpha = alpha; const drawEffects = !this.isBot || enableEnemyFX;
            if (isSprinting && drawEffects) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(-Math.PI / 4); let pW = this.r * 2.0, pH = pW * PILL_RATIO, rBox = pW / 2; ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 30; ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.beginPath(); ctx.roundRect(-pW/2 - 5, -pH/2 - 5, pW + 10, pH + 10, rBox); ctx.fill(); ctx.restore(); }
            if (this.immuneTime > 0 && drawEffects) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(-Math.PI / 4); let pW = this.r * 2.0, pH = pW * PILL_RATIO, rBox = pW / 2, gap = this.r * 0.1; ctx.strokeStyle = '#a020f0'; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = '#a020f0'; ctx.beginPath(); ctx.roundRect(-pW/2 - gap, -pH/2 - gap, pW + gap*2, pH + gap*2, rBox + gap); ctx.stroke();
                let time = performance.now() / 1200, shieldScale = Math.max(0.6, this.r / 25), shieldW = pW + gap*2, shieldH = pH + gap*2; for(let i=0; i<4; i++) { let angle = time + (i * (Math.PI / 2)), sx = Math.cos(angle) * (shieldW/2 + (10 * shieldScale)), sy = Math.sin(angle) * (shieldH/2 + (10 * shieldScale)); ctx.save(); ctx.translate(sx, sy); ctx.scale(shieldScale, shieldScale); ctx.rotate(-angle); ctx.fillStyle = '#a020f0'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(6, -6); ctx.lineTo(6, 0); ctx.quadraticCurveTo(6, 8, 0, 10); ctx.quadraticCurveTo(-6, 8, -6, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2; ctx.moveTo(0, -4); ctx.lineTo(0, 6); ctx.moveTo(-4, 0); ctx.lineTo(4, 0); ctx.stroke(); ctx.restore(); } ctx.restore();
            }
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(-Math.PI / 4); let pW = this.r * 2.0, pH = pW * PILL_RATIO, rBox = pW / 2; 
            if(this.flashTime > 0 && this.flashColor && drawEffects) { ctx.save(); ctx.shadowBlur = 50; ctx.shadowColor = this.flashColor; ctx.fillStyle = this.flashColor; ctx.globalAlpha = 0.35 * alpha; ctx.beginPath(); ctx.roundRect(-pW/2 - 10, -pH/2 - 10, pW + 20, pH + 20, rBox + 10); ctx.fill(); ctx.restore(); } 
            ctx.beginPath(); ctx.roundRect(-pW/2, -pH/2, pW, pH, rBox); ctx.clip(); 
            if (this.skin && this.skin.complete && this.skin.naturalWidth > 0) { try { ctx.drawImage(this.skin, -pW/2, -pH/2, pW, pH); } catch (e) { this.drawColors(pW, pH); } } else { this.drawColors(pW, pH); } 
            if (this.immuneTime > 0 && drawEffects) { ctx.fillStyle = 'rgba(160, 32, 240, 0.4)'; ctx.fill(); }
            ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.ellipse(-pW/4, -pH/4, pW/5, pH/6, 0, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.roundRect(-pW/2, -pH/2, pW, pH, rBox); ctx.lineWidth = Math.max(2, this.r * 0.1); ctx.strokeStyle = '#222'; ctx.stroke(); ctx.restore(); 
            if (this.particles.length > 0 && drawEffects) { 
                ctx.save(); ctx.translate(this.x, this.y); 
                this.particles.forEach(p => { 
                    ctx.save(); ctx.translate(p.x, p.y); ctx.globalAlpha = p.life * alpha; 
                    if (p.type === 'BOLT') { ctx.scale(p.scale, p.scale); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 3; ctx.shadowColor = '#FFF'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(0, 0); ctx.lineTo(-2, 2); ctx.lineTo(5, 5); ctx.stroke(); } 
                    else { ctx.font = `bold ${Math.max(16, this.r/1.5)}px Russo One`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; if (p.type === 'PLUS') { ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 5; ctx.fillText("+", 0, 0); } else { ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 5; ctx.fillText("-", 0, 0); } } 
                    ctx.restore(); 
                }); 
                ctx.restore(); 
            }
            if (this.name) { ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3; let fSize = Math.max(12, this.r / 1.2); ctx.font = `bold ${fSize}px Russo One`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.strokeText(this.name, this.x, this.y - (this.r * PILL_RATIO) + 5); ctx.fillText(this.name, this.x, this.y - (this.r * PILL_RATIO) + 5); } 
            ctx.restore();
        }
        drawColors(w, h) { ctx.fillStyle = this.colorTop; ctx.fillRect(-w/2, -h/2, w, h/2); ctx.fillStyle = this.colorBot; ctx.fillRect(-w/2, 0, w, h/2); }
    }

    class Explosion { constructor(x, y) { this.x = x; this.y = y; this.life = 1.0; this.particles = []; for(let i=0; i<16; i++) { let angle = (Math.PI*2 * i) / 16; this.particles.push({ x: 0, y: 0, vx: Math.cos(angle)*8, vy: Math.sin(angle)*8, r: Math.random()*5+5, rot: Math.random()*Math.PI }); } } update() { this.life -= 0.02; this.particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.rot+=0.1; }); } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = Math.max(0, this.life); this.particles.forEach(p => { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot); ctx.fillStyle = '#81F126'; ctx.strokeStyle = '#3E8E11'; ctx.lineWidth = 2; ctx.beginPath(); for(let i=0; i<12; i++) { let r = (i%2===0) ? p.r : p.r/2; ctx.lineTo(Math.cos((Math.PI*i)/6)*r, Math.sin((Math.PI*i)/6)*r); } ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }); ctx.restore(); } }

    function tryPlayHover(m) { if (ignoreNextHover) { if (m !== lastHoveredMode) { ignoreNextHover = false; SoundManager.play('hover'); } } else { SoundManager.play('hover'); } }
    function setHoverMode(m) { lastHoveredMode = m; if(m === 'classic') { els.modeScreen.classList.add('hover-classic'); els.modeScreen.classList.remove('hover-arcade'); } else if(m === 'arcade') { els.modeScreen.classList.add('hover-arcade'); els.modeScreen.classList.remove('hover-classic'); } }
    els.modeScreen.onmouseleave = () => { els.modeScreen.classList.remove('hover-classic', 'hover-arcade'); lastHoveredMode = null; };
    
    function selectMode(m) { 
        SoundManager.stop('hover'); SoundManager.play('select'); ignoreNextHover = true; currentGameMode = m; 
        els.modeScreen.style.pointerEvents = 'none'; document.getElementById('contentClassic').style.opacity = '0'; document.getElementById('contentArcade').style.opacity = '0'; document.querySelector('.diagonal-divider').style.opacity = '0'; 
        const loginBox = document.querySelector('.login-box');
        const splitSelect = document.getElementById('botSplitLimit');
        if (m === 'classic') { 
            document.getElementById('panelClassic').classList.add('expanded'); document.getElementById('panelArcade').classList.add('hidden'); 
            els.selectedModeTitle.innerText = "CLASSIC MODE"; els.selectedModeTitle.style.color = "#00ffaa"; 
            els.loginOverlay.classList.remove('bg-arcade'); els.loginOverlay.classList.add('bg-classic'); 
            document.getElementById('arcadeGuidePanel').style.display = 'none'; document.getElementById('classicGuidePanel').style.display = 'flex'; 
            loginBox.style.width = '850px'; splitSelect.value = "8";
        } else { 
            document.getElementById('panelArcade').classList.add('expanded'); document.getElementById('panelClassic').classList.add('hidden'); 
            els.selectedModeTitle.innerText = "ARCADE MODE"; els.selectedModeTitle.style.color = "#ccff00"; 
            els.loginOverlay.classList.remove('bg-classic'); els.loginOverlay.classList.add('bg-arcade'); 
            document.getElementById('arcadeGuidePanel').style.display = 'flex'; document.getElementById('classicGuidePanel').style.display = 'none'; 
            loginBox.style.width = '850px'; initArcadeGuide(); splitSelect.value = "4";
        } 
        MAX_BOT_CELLS = parseInt(splitSelect.value); 
        checkActiveRoomConfig();
        setTimeout(() => { els.modeScreen.style.display = 'none'; els.loginOverlay.style.display = 'flex'; els.modeScreen.style.pointerEvents = 'auto'; }, 1200); 
        
        // --- MOBILE LAYOUT UPDATE ---
        updateMobileButtons();
    }
    
    // --- NUEVA FUNCI√ìN PARA ACTUALIZAR BOTONES M√ìVILES SEG√öN MODO ---
    function updateMobileButtons() {
        if (currentGameMode === 'classic') {
            document.getElementById('mobArcadeSlots').style.display = 'none';
            document.getElementById('mobShootBtn').style.display = 'flex';
        } else {
            // Arcade mode: 4 slots, no basic shoot
            document.getElementById('mobArcadeSlots').style.display = 'grid';
            document.getElementById('mobShootBtn').style.display = 'none';
        }
    }

    function goBackToModes() { 
        SoundManager.play('select'); ignoreNextHover = true; els.loginOverlay.style.display = 'none'; els.skillOverlay.style.display = 'none';
        els.modeScreen.style.display = 'flex'; document.getElementById('panelClassic').classList.remove('expanded', 'hidden'); document.getElementById('panelArcade').classList.remove('expanded', 'hidden'); 
        document.getElementById('contentClassic').style.opacity = '1'; document.getElementById('contentArcade').style.opacity = '0.7'; document.querySelector('.diagonal-divider').style.opacity = '1'; 
        if(currentGameMode === 'classic') setHoverMode('classic'); else setHoverMode('arcade'); currentGameMode = null; 
    }
    function toggleStyleUI() { const m = document.querySelector('input[name="styleMode"]:checked').value; document.getElementById('colorPickersContainer').style.display = (m === 'color') ? 'flex' : 'none'; document.getElementById('skinInputContainer').style.display = (m === 'skin') ? 'block' : 'none'; }
    function toggleBotOptions() { const isChecked = document.getElementById('botsToggle').checked; document.getElementById('botOptionsGroup').style.opacity = isChecked ? "1" : "0.3"; document.getElementById('botOptionsGroup').style.pointerEvents = isChecked ? "auto" : "none"; }

    function selectServer(a, b) { SoundManager.play('simpleselect'); gameRunning = false; currentServer = a; document.querySelectorAll('.srv-btn').forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); checkActiveRoomConfig(); }
    function toggleExitModal() {
        if(!gameRunning) return;
        const modal = document.getElementById('exitModal'); const btn = document.getElementById('btnConfirmExit'); const title = document.getElementById('exitModalTitle'); const desc = document.getElementById('exitModalDesc');
        if (logoutTimer) clearInterval(logoutTimer); btn.disabled = false; btn.innerText = "EXIT";
        if(modal.style.display === 'flex') { modal.style.display = 'none'; isLoggingOut = false; } else {
            modal.style.display = 'flex';
            if (currentGameMode === 'classic') {
                title.innerText = "SECURE CASHOUT"; let penaltyText = "", color = "";
                if (currentKillStreak < 2) { penaltyText = "WARNING: 10% FEE (Kills < 2)"; color = "#ff2a2a"; } else { penaltyText = "SAFE EXIT: 0% FEE (Kills 2+)"; color = "#00ff88"; }
                desc.innerHTML = `You have <span style="color:#fff">${currentKillStreak} Kills</span>.<br><span style="color:${color}; font-weight:bold;">${penaltyText}</span><br>Stand still for 5s to CASHOUT safely.<br><span style="font-size:10px; color:#888;">(Your progress will be wiped to collect rewards)</span>`;
                btn.onclick = startClassicLogout; btn.innerText = "START CASHOUT (5s)";
            } else { title.innerText = "WARNING: FORFEIT?"; desc.innerHTML = "You will lose <span style='color:#ff2a2a'>100% of the PILLS</span> used to enter.<br>Are you sure?"; btn.onclick = confirmExit; btn.innerText = "EXIT NOW"; }
        }
    }

    function startClassicLogout() {
        const btn = document.getElementById('btnConfirmExit'); btn.disabled = true; isLoggingOut = true; let timeLeft = 5; btn.innerText = `WAIT ${timeLeft}s...`;
        if (logoutTimer) clearInterval(logoutTimer); logoutTimer = setInterval(() => { timeLeft--; if (timeLeft <= 0) { clearInterval(logoutTimer); confirmExit(); } else { btn.innerText = `WAIT ${timeLeft}s...`; } }, 1000);
    }
    
    function confirmExit() { document.getElementById('exitModal').style.display = 'none'; isLoggingOut = false; localStorage.removeItem('pillwars_save'); if(saveInterval) clearInterval(saveInterval); returnToMenu(); }
    function forceResetRoom() { if (!confirm("Reset current room state? (Only affects your local simulation)")) return; let roomKey = currentGameMode + '_' + currentServer; roomStates[roomKey] = null; roomTimers[roomKey] = 0; localStorage.removeItem('pillwars_save'); checkActiveRoomConfig(); }

    function init() { 
        SoundManager.init(); resize(); 
        for(let i=1; i<=10; i++) { 
            uiSlots[i] = document.getElementById('slot'+i); 
            uiCounts[i] = document.getElementById('count'+i); 
            uiOverlays[i] = document.getElementById('cd'+i); 
            uiOverlaysActive[i] = document.getElementById('dur'+i); 
            uiIcons[i] = document.getElementById('icon'+i); 
            uiGcds[i] = document.getElementById('gcd'+i); 
        } 
        
        // Map arcade slots in DOM to the JS logic for mobile too (optional visual sync)
        // (Logic handled in updateSkillsUI_Arcade)

        els.skillOverlay.style.top = UI_PARAMS.skillSelectTop; window.addEventListener('resize', resize); 
        els.actionBar.addEventListener('mouseenter', () => isHoveringUI = true); els.actionBar.addEventListener('mouseleave', () => isHoveringUI = false);
        els.skillOverlay.addEventListener('mouseenter', () => isHoveringUI = true); els.skillOverlay.addEventListener('mouseleave', () => isHoveringUI = false);
        document.getElementById('exitGameBtn').addEventListener('mouseenter', () => isHoveringUI = true); document.getElementById('exitGameBtn').addEventListener('mouseleave', () => isHoveringUI = false);
        window.addEventListener('blur', () => { keys.w = false; keys.a = false; keys.s = false; keys.d = false; });
        window.addEventListener('beforeunload', () => { if (gameRunning && !isSpectating && player.cells.length > 0) { saveSystem.save(); } });
        window.addEventListener('mousedown', e => { if(isSpectating && !isHoveringUI) { isSpecDragging = true; lastSpecX = e.clientX; lastSpecY = e.clientY; } });
        window.addEventListener('mouseup', () => { isSpecDragging = false; });
        window.addEventListener('mousemove', e => { if(isHoveringUI || isLoggingOut) return; mouse.x = e.clientX; mouse.y = e.clientY; if (!isSpectating && !(keys.w || keys.a || keys.s || keys.d)) { inputMode = 'MOUSE'; } });
        
        // --- TOUCH CONTROLS ---
        // Basic touch for desktop emulation (fallback)
        window.addEventListener('touchmove', e => { 
            if (!gameRunning || isLoggingOut) return; 
            // If joystick is active, don't use global touch for movement
            if (isMobileInput) return;
            
            e.preventDefault(); const t = e.touches[0]; mouse.x = t.clientX; mouse.y = t.clientY; inputMode = 'MOUSE'; 
        }, {passive: false}); 

        window.addEventListener('touchstart', e => { 
            if(e.target.closest('.ab-slot, button, #loginOverlay, #resultOverlay, #skillChoiceOverlay, #exitGameBtn, #exitModal, .nav-btn, #mobileControls, #globalFullscreenBtn')) return; 
            
            // Skill Choice handling on Mobile (Arcade)
            if (isPickingSkill && currentGameMode !== 'classic') {
                // If user taps outside buttons, maybe cycle choice or do nothing.
                // Already handled by .skill-opt-btn click.
                return; 
            }

            const now = Date.now(); 
            if (now - lastTapTime < 300) { splitPlayer(); e.preventDefault(); } 
            else { 
                if(e.touches[0] && !isLoggingOut && !isMobileInput){ 
                    mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; inputMode = 'MOUSE'; 
                } 
            } 
            lastTapTime = now; 
        }, {passive: false}); 

        window.addEventListener('keydown', e => { 
            if (!gameRunning) return; if (e.code === 'Escape') { toggleExitModal(); return; }
            if (isPickingSkill) { if (e.code === 'Tab') { e.preventDefault(); SoundManager.playSimpleHover(); skillChoiceIndex = (skillChoiceIndex === 0) ? 1 : 0; updateChoiceVisuals(); return; } if (e.code === 'KeyQ') { let options = els.skillOpts.children; if(options[skillChoiceIndex]) options[skillChoiceIndex].click(); return; } }
            if (e.code.startsWith('Digit')) { let n = parseInt(e.code.slice(-1)); if(n === 0) n = 10; if (n >= 1 && n <= 10) { if(uiSlots[n]) uiSlots[n].classList.add('active'); useSkill(n); } }
            if (e.code === 'Space') splitPlayer(); if (['KeyW','KeyA','KeyS','KeyD'].includes(e.code)) { inputMode = 'KEYBOARD'; if(!isLoggingOut) keys[e.code.slice(-1).toLowerCase()] = true; } 
        });
        window.addEventListener('keyup', e => { if (e.code.startsWith('Digit')) { let id = parseInt(e.code.slice(-1)); if(id === 0) id = 10; if(id >= 1 && id <= 10 && uiSlots[id]) uiSlots[id].classList.remove('active'); } if (['KeyW','KeyA','KeyS','KeyD'].includes(e.code)) keys[e.code.slice(-1).toLowerCase()] = false; });
        
        initMobileControls();
        loop(); 
    }

    // --- MOBILE JOYSTICK LOGIC ---
    function initMobileControls() {
        // Detect if mobile
        if(window.innerWidth <= 900) {
            isMobileInput = true;
        }

        const zone = document.getElementById('joystickZone');
        const stick = document.getElementById('stick');

        zone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joyTouchId = touch.identifier;
            const rect = zone.getBoundingClientRect();
            // Center of joystick zone
            joyStartX = rect.left + rect.width / 2;
            joyStartY = rect.top + rect.height / 2;
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive: false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyTouchId) {
                    updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    break;
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyTouchId) {
                    joyTouchId = null;
                    joyMoveX = 0; joyMoveY = 0;
                    stick.style.transform = `translate(-50%, -50%)`;
                    // Reset mouse to center to stop moving when release? 
                    // Or keep last direction? Standard .io is stop or keep.
                    // Let's set input to center to stop.
                    mouse.x = width/2; mouse.y = height/2;
                    break;
                }
            }
        };

        zone.addEventListener('touchend', endJoystick);
        zone.addEventListener('touchcancel', endJoystick);

        function updateJoystick(clientX, clientY) {
            const maxDist = 35; // Stick movement radius
            let dx = clientX - joyStartX;
            let dy = clientY - joyStartY;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > maxDist) {
                const ratio = maxDist / dist;
                dx *= ratio;
                dy *= ratio;
            }

            stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            // Map to Game Mouse Coordinates relative to center
            // "mouse" variable needs to be absolute screen coordinates that mimic looking at that point
            // so physics calculate angle correctly.
            // Center is width/2, height/2.
            // We project a point far away in that direction.
            const angle = Math.atan2(dy, dx);
            const projectDist = 500; // Arbitrary distance to ensure movement
            mouse.x = (width/2) + Math.cos(angle) * projectDist;
            mouse.y = (height/2) + Math.sin(angle) * projectDist;
            inputMode = 'MOUSE';
        }
    }

    // --- MOBILE ACTION HANDLERS ---
    function splitPlayerMobile(e) {
        e.preventDefault();
        splitPlayer();
    }
    
    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {});
        } else {
            document.exitFullscreen();
        }
    }

    function dragStart(ev, idx) { if(currentGameMode !== 'arcade' && currentGameMode !== 'skills') return; draggedIdx = idx; ev.dataTransfer.effectAllowed = "move"; }
    function allowDrop(ev) { if(currentGameMode !== 'arcade' && currentGameMode !== 'skills') return; ev.preventDefault(); }
    function drop(ev, dropIdx) { if(currentGameMode !== 'arcade' && currentGameMode !== 'skills') return; ev.preventDefault(); if(draggedIdx === -1 || draggedIdx === dropIdx) return; let temp = playerSkills[draggedIdx]; playerSkills[draggedIdx] = playerSkills[dropIdx]; playerSkills[dropIdx] = temp; updateSkillsUI_Arcade(); draggedIdx = -1; }
    function removeSkill(slotIdx) { let idx = slotIdx - 1; if(playerSkills[idx] && !isGodMode && playerSkills[idx].uses <= 0) { playerSkills[idx] = null; updateSkillsUI_Arcade(); } }
    
    // Updated for Mobile Arcade Buttons + Desktop
    function activateSkillTouch(slotIdx, event) { 
        if (event) { event.preventDefault(); event.stopPropagation(); }
        if(currentGameMode === 'classic' && slotIdx !== 1) return; 
        
        // Visual feedback on DOM
        if(uiSlots[slotIdx]) { uiSlots[slotIdx].classList.add('active'); setTimeout(() => uiSlots[slotIdx].classList.remove('active'), 150); }
        // Mobile DOM feedback
        const mobSlot = document.getElementById('mobSlot'+slotIdx);
        if(mobSlot) { mobSlot.classList.add('active'); setTimeout(() => mobSlot.classList.remove('active'), 150); }
        
        useSkill(slotIdx); 
    }

    function useSkill(slotIndex) {
        if (!gameRunning) return; if (globalCDTimer > 0) { SoundManager.play('cd'); return; }
        if (currentGameMode === 'classic') { if (slotIndex === 1) { if (player.cells.some(c => c.mass > SKILL_PARAMS.shootCost + 314) || isGodMode) { emitProjectile('shoot', SKILL_PARAMS.shootCost); globalCDTimer = GLOBAL_CD_MS; } } else if (slotIndex === 2 && isGodMode) { let totalGain = 10000; let gainPerCell = (player.cells.length > 0) ? (totalGain / player.cells.length) : totalGain; player.cells.forEach(c => { c.r = Math.sqrt((c.mass + gainPerCell) / (Math.PI * PILL_RATIO)); c.flashColor = '#00ff00'; c.flashTime = 1000; c.spawnParticles('PLUS'); }); spawnFloatingText("GOD MODE MASS", "#00FF00"); SoundManager.play('big'); globalCDTimer = 200; } return; }
        if(slotIndex > playerSkills.length) return; let skillObj = playerSkills[slotIndex - 1]; if (skillObj && skillObj.uses <= 0 && !isGodMode) { playerSkills[slotIndex - 1] = null; updateSkillsUI_Arcade(); return; }
        if (!skillObj) return; let def = skills[skillObj.id]; if (def.active > 0) return; let activated = false, id = skillObj.id;
        if (id === 1) { if(player.cells.some(c => c.mass > SKILL_PARAMS.clonCost + 314) || isGodMode) { emitProjectile('clon', SKILL_PARAMS.clonCost); activated = true; } } 
        else if (id === 2) { if(player.cells.some(c => c.mass > SKILL_PARAMS.shootCost + 314) || isGodMode) { emitProjectile('shoot', SKILL_PARAMS.shootCost); activated = true; } }
        else if (id === 3) { activated = true; spawnFloatingText("+ SPEED", "#00FFFF"); SoundManager.play('sprint'); } 
        else if (id === 4) { let limit = MAP_SIZE - 300; let targetX = Math.random() * (limit * 2) - limit; let targetY = Math.random() * (limit * 2) - limit; let avgX = 0, avgY = 0; player.cells.forEach(c => { avgX += c.x; avgY += c.y; }); avgX /= player.cells.length; avgY /= player.cells.length; let dx = targetX - avgX, dy = targetY - avgY; player.cells.forEach(c => { c.tpPhase = 1; c.tpTimer = 500; c.tpDest = { x: c.x + dx, y: c.y + dy }; }); activated = true; SoundManager.play('tp'); }
        else if (id === 5) { activated = true; spawnFloatingText("+ MAGNET POWER", "#A020F0"); SoundManager.play('iman'); } 
        else if (id === 6) { player.cells.forEach(c => c.immuneTime = SKILL_PARAMS.shieldDuration); activated = true; spawnFloatingText("IMMUNITY", "#FFD700"); SoundManager.play('shield'); }
        else if (id === 7) { let totalGain = Math.floor(Math.random() * (SKILL_PARAMS.bigMax - SKILL_PARAMS.bigMin + 1)) + SKILL_PARAMS.bigMin, gainPerCell = (player.cells.length > 0) ? (totalGain / player.cells.length) : totalGain; player.cells.forEach(c => { c.r = Math.sqrt((c.mass + gainPerCell) / (Math.PI * PILL_RATIO)); c.flashColor = '#00ff00'; c.flashTime = 1000; c.spawnParticles('PLUS'); }); activated = true; spawnFloatingText("MASS UP", "#00FF00"); SoundManager.play('big'); }
        else if (id === 8) { let totalVal = (Math.random() < 0.5) ? -5000 : 15000, valPerCell = (player.cells.length > 0) ? (totalVal / player.cells.length) : totalVal; player.cells.forEach(c => { let newMass = c.mass + valPerCell; if(newMass < 314) newMass = 314; c.r = Math.sqrt(newMass / (Math.PI * PILL_RATIO)); c.flashColor = (valPerCell >= 0) ? '#00ff00' : '#ff0000'; c.flashTime = 1000; c.spawnParticles(valPerCell >= 0 ? 'PLUS' : 'MINUS'); }); activated = true; if (totalVal >= 0) { spawnFloatingText("LUCKY! +MASS", "#00FF00"); SoundManager.play('big'); } else { spawnFloatingText("UNLUCKY! -MASS", "#FF0000"); SoundManager.play('little'); } }
        if (activated) { if (!isGodMode) skillObj.uses--; if (id === 3 || id === 4 || id === 5 || id === 6 || id === 7 || id === 8) { def.active = def.maxActive; } globalCDTimer = GLOBAL_CD_MS; updateSkillsUI_Arcade(); }
    }

    function updateSkillsUI_Arcade() {
        if(currentGameMode !== 'arcade' && currentGameMode !== 'skills') return;
        for(let i=0; i<10; i++) {
            let slotNum = i+1, divSlot = uiSlots[slotNum]; 
            // Mobile Slot Update
            let mobSlot = document.getElementById('mobSlot'+slotNum);

            if (i >= playerSkills.length) { 
                if(divSlot) divSlot.style.display = 'none'; 
                if(mobSlot) mobSlot.style.display = 'none';
                continue; 
            } else { 
                if(divSlot) divSlot.style.display = 'flex'; 
                if(mobSlot) mobSlot.style.display = 'flex';
            }

            let skill = playerSkills[i], iconDiv = uiIcons[slotNum], countBadge = uiCounts[slotNum]; 
            if(!iconDiv) continue; 
            iconDiv.className = 'skill-icon';

            if (skill) { 
                let def = skills[skill.id]; 
                // Desktop
                iconDiv.classList.add(def.icon); 
                countBadge.style.display = 'block'; 
                countBadge.innerText = isGodMode ? "‚àû" : skill.uses; 
                countBadge.style.background = (skill.uses <= 0 && !isGodMode) ? '#555' : '#ff2a2a'; 
                uiSlots[slotNum].style.opacity = (skill.uses <= 0 && !isGodMode) ? '0.5' : '1'; 
                uiSlots[slotNum].style.cursor = (skill.uses <= 0 && !isGodMode) ? 'alias' : 'grab'; 

                // Mobile
                if(mobSlot) {
                    mobSlot.style.backgroundImage = `url('${SKILL_DESCRIPTIONS[skill.id].icon}')`;
                    mobSlot.style.backgroundSize = "contain";
                    mobSlot.style.backgroundRepeat = "no-repeat";
                    mobSlot.style.backgroundPosition = "center";
                    mobSlot.style.opacity = (skill.uses <= 0 && !isGodMode) ? '0.5' : '1'; 
                    mobSlot.innerText = isGodMode ? "" : (skill.uses > 1 ? skill.uses : "");
                }
            } else { 
                // Desktop
                iconDiv.classList.add('icon-empty'); 
                countBadge.style.display = 'none'; 
                uiSlots[slotNum].style.opacity = '1'; 
                uiOverlays[slotNum].style.height = '0%'; 
                uiOverlaysActive[slotNum].style.height = '0%'; 
                uiSlots[slotNum].style.cursor = 'grab'; 

                // Mobile
                if(mobSlot) {
                    mobSlot.style.backgroundImage = "none";
                    mobSlot.style.background = "rgba(0,0,0,0.6)";
                    mobSlot.innerText = "";
                }
            }
        }
    }

    function generateWorldData() {
        let sizeMult = worldSettings.map || 1; let foodMult = worldSettings.food || 1; let virusMult = worldSettings.virus || 1;
        let currentMapSize = MAP_SIZE * sizeMult; let areaMillions = Math.pow(currentMapSize * 2, 2) / 1000000; 
        let foodCount = Math.floor(areaMillions * WORLD_CONFIG.foodDensity); let virusCount = Math.floor(areaMillions * WORLD_CONFIG.virusDensity * virusMult);
        let f = [], v = [], e = [];
        for(let i=0; i<foodCount; i++) { 
            spawnFoodSafe(f, currentMapSize);
        }
        for(let i=0; i<virusCount; i++) { spawnVirusSafe(v, currentMapSize); }
        if (botConfig.enabled) { for(let i=0; i<botConfig.count; i++) { let p = getSafePos(currentMapSize); let name = BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)]; e.push(new Cell(p.x, p.y, Math.random() * 5 + 14, getRandomColor(), getRandomColor(), name, true, null)); } }
        return { foods: f, viruses: v, enemies: e, projectiles: [], ejected: [] };
    }

    function spawnFoodSafe(foodArray, limit = MAP_SIZE) {
        let food = foodPool.get();
        food.x = Math.random()*limit*2-limit;
        food.y = Math.random()*limit*2-limit;
        food.r = Math.random()*4+5;
        food.c1 = COLORS[Math.floor(Math.random()*COLORS.length)];
        food.c2 = COLORS[Math.floor(Math.random()*COLORS.length)];
        food.angle = Math.random()*Math.PI;
        food.spikes = [];
        for(let j=0; j<4; j++) food.spikes.push(Math.random() * Math.PI * 2);
        foodArray.push(food);
    }

    function spawnVirusSafe(virusArray, limit = MAP_SIZE) {
        let attempts = 0, x, y, valid; do { x = Math.random() * limit * 2 - limit; y = Math.random() * limit * 2 - limit; valid = true; for(let other of virusArray) { if(Math.hypot(x - other.x, y - other.y) < 350) { valid = false; break; } } attempts++; } while(!valid && attempts < 30);
        let spots = []; for(let k=0; k<2; k++) { let angle = Math.random() * Math.PI * 2; let dist = Math.random() * (VIRUS_RADIUS * 0.5); spots.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist, r: Math.random() * 8 + 4 }); }
        let v = virusPool.get();
        v.x = x; v.y = y; v.r = VIRUS_RADIUS; v.vx = 0; v.vy = 0; v.hits = 0; v.damaged = false; v.animTime = 0; v.spots = spots;
        virusArray.push(v);
    }

    const saveSystem = {
        key: 'pillwars_save',
        save: function() {
            const pCells = player.cells.map(c => ({ x: c.x, y: c.y, r: c.r, colorBot: c.colorBot, colorTop: c.colorTop, name: c.name, skinSrc: c.skin ? c.skin.src : null, id: c.id }));
            const eCells = enemies.map(c => ({ x: c.x, y: c.y, r: c.r, colorBot: c.colorBot, colorTop: c.colorTop, name: c.name, id: c.id, botSkills: c.botSkills, massMilestoneMet: c.massMilestoneMet }));
            const data = { mode: currentGameMode, server: currentServer, player: { name: player.name, cells: pCells, skills: playerSkills, killStreak: currentKillStreak }, enemies: eCells, timers: roomTimers, arcadeState: { nextPick: nextSkillPickTime, milestone: massMilestoneReached }, timestamp: Date.now() }; localStorage.setItem(this.key, JSON.stringify(data));
        },
        load: function() { const str = localStorage.getItem(this.key); if(!str) return null; try { return JSON.parse(str); } catch(e) { return null; } },
        hasSaveForRoom: function(mode, server) { const data = this.load(); if(!data) return false; if(Date.now() - data.timestamp > 20 * 60 * 1000) return false; return data.mode === mode && data.server === server && data.player.cells.length > 0; }
    };

    function startGame() {
        SoundManager.play('select'); SoundManager.playMusic(); 
        player.name = document.getElementById('playerNameInput').value.trim() || "";
        if (selectedQuality === 'high') DRAW_LOD_THRESHOLD = 1; else if (selectedQuality === 'normal') DRAW_LOD_THRESHOLD = 3; else if (selectedQuality === 'low') DRAW_LOD_THRESHOLD = 6; else if (selectedQuality === 'ultra') { DRAW_LOD_THRESHOLD = 6; isLowQuality = true; } else { isLowQuality = false; DRAW_LOD_THRESHOLD = 3; }
        MAX_BOT_CELLS = parseInt(document.getElementById('botSplitLimit').value);
        worldSettings.map = parseInt(document.getElementById('mapMult').value); worldSettings.food = parseInt(document.getElementById('foodMult').value); worldSettings.virus = parseInt(document.getElementById('virusMult').value); worldSettings.speed = parseFloat(document.getElementById('speedMult').value);
        let currentBotConfig = { botEnabled: document.getElementById('botsToggle').checked, botCount: parseInt(document.getElementById('botCountInput').value), botRespawn: document.getElementById('botRespawnToggle').checked, chaosMode: document.getElementById('chaosModeToggle') ? document.getElementById('chaosModeToggle').checked : false, botMaxSplits: MAX_BOT_CELLS, world: {...worldSettings} };
        enableEnemyFX = !document.getElementById('noEnemyFX').checked; enableEnemySnd = !document.getElementById('noEnemySnd').checked;
        const isChaosMode = document.getElementById('chaosModeToggle').checked; if (currentGameMode === 'arcade' && isChaosMode) { currentGameMode = 'skills'; }
        isGodMode = document.getElementById('godModeToggle').checked; isSpectating = false; 
        if (currentGameMode === 'classic') { MAP_SIZE = WORLD_CONFIG.classic.size; els.actionBar.style.display = 'none'; } else { MAP_SIZE = WORLD_CONFIG.arcade.size; els.actionBar.style.display = 'flex'; playerSkills = isGodMode ? Array(10).fill().map((_,k)=>(k<8?{id:k+1,uses:999}:null)) : [null, null, null, null]; massMilestoneReached = false; nextSkillPickTime = 30; isPickingSkill = false; els.skillOverlay.style.display = 'none'; updateSkillsUI_Arcade(); }
        MAP_SIZE *= worldSettings.map;
        const skinUrlVal = document.getElementById('secretSkinInput').value; const useSkin = (document.getElementById('secretSkinPanel').style.display === 'block') && skinUrlVal.length > 5;
        currentKillStreak = 0; splitMilestones = { level1: false, level2: false }; botConfig.enabled = document.getElementById('botsToggle').checked; botConfig.count = parseInt(document.getElementById('botCountInput').value); botConfig.respawn = document.getElementById('botRespawnToggle').checked;
        let roomKey = currentGameMode + '_' + currentServer;
        let loadedSave = false;
        if (saveSystem.hasSaveForRoom(currentGameMode, currentServer)) {
            const saveData = saveSystem.load();
            if(saveData) {
                player.cells = saveData.player.cells.map(c => new Cell(c.x, c.y, c.r, c.colorBot, c.colorTop, c.name, false, c.skinSrc, c.id)); if(saveData.player.skills) playerSkills = saveData.player.skills; currentKillStreak = saveData.player.killStreak || 0;
                enemies = saveData.enemies.map(c => { let e = new Cell(c.x, c.y, c.r, c.colorBot, c.colorTop, c.name, true, null, c.id); e.botSkills = c.botSkills || []; e.massMilestoneMet = c.massMilestoneMet; return e; });
                if(saveData.timers) roomTimers = saveData.timers; if(saveData.arcadeState) { nextSkillPickTime = saveData.arcadeState.nextPick; massMilestoneReached = saveData.arcadeState.milestone; }
                if(!roomStates[roomKey]) { let newData = generateWorldData(); foods = newData.foods; viruses = newData.viruses; roomStates[roomKey] = { foods, viruses, enemies, projectiles: [], ejected: [], config: currentBotConfig }; } else { roomStates[roomKey].enemies = enemies; foods = roomStates[roomKey].foods; viruses = roomStates[roomKey].viruses; }
                if(player.cells.length > 0) { camera.x = player.cells[0].x; camera.y = player.cells[0].y; } loadedSave = true; updateSkillsUI_Arcade();
            }
        }
        if(!roomTimers[roomKey] || roomTimers[roomKey] <= Date.now()) { if(GAME_DURATION_MS) roomTimers[roomKey] = Date.now() + GAME_DURATION_MS; }
        if (!loadedSave) {
            let needsRegen = false; if (!roomStates[roomKey]) needsRegen = true;
            if (needsRegen) { let newData = generateWorldData(); foods = newData.foods; viruses = newData.viruses; enemies = newData.enemies; projectiles = []; ejectedMasses = []; explosions = []; roomStates[roomKey] = { foods, viruses, enemies, projectiles, ejected: ejectedMasses, config: currentBotConfig }; } 
            else { let s = roomStates[roomKey]; foods = s.foods; viruses = s.viruses; enemies = s.enemies; projectiles = s.projectiles; ejectedMasses = s.ejected; explosions = []; if(s.config) { botConfig.enabled = s.config.botEnabled; botConfig.count = s.config.botCount; botConfig.respawn = s.config.botRespawn; } }
            for(let i=1; i<=8; i++) skills[i].active = 0; let startPos = getSafePos(MAP_SIZE), colTop = document.getElementById('colTop').value, colBot = document.getElementById('colBot').value; let skin = useSkin ? skinUrlVal : null;
            player.cells = [ new Cell(startPos.x, startPos.y, INITIAL_RADIUS, colBot, colTop, player.name, false, skin, "me") ]; camera.x = startPos.x; camera.y = startPos.y; 
        }
        els.room.innerText = currentServer; els.loginOverlay.style.display = 'none'; els.result.style.display = 'none'; 
        document.getElementById('ui').style.display = 'flex'; document.getElementById('leaderboard').style.display = 'block'; document.getElementById('timerDisplay').style.display = 'block'; document.getElementById('exitGameBtn').style.display = 'flex'; 
        if(saveInterval) clearInterval(saveInterval); saveInterval = setInterval(() => { if(gameRunning && !isSpectating && player.cells.length > 0) saveSystem.save(); }, 2000);
        gameRunning = true;
    }
    
    let saveInterval = null;

    function startSpectatorMode() {
        SoundManager.play('select'); botConfig.enabled = document.getElementById('botsToggle').checked; botConfig.count = parseInt(document.getElementById('botCountInput').value); botConfig.respawn = document.getElementById('botRespawnToggle').checked; MAX_BOT_CELLS = parseInt(document.getElementById('botSplitLimit').value); worldSettings.map = parseInt(document.getElementById('mapMult').value); worldSettings.food = parseInt(document.getElementById('foodMult').value); worldSettings.virus = parseInt(document.getElementById('virusMult').value); worldSettings.speed = parseFloat(document.getElementById('speedMult').value); enableEnemyFX = !document.getElementById('noEnemyFX').checked; enableEnemySnd = !document.getElementById('noEnemySnd').checked;
        let currentBotConfig = { botEnabled: botConfig.enabled, botCount: botConfig.count, botRespawn: botConfig.respawn, chaosMode: document.getElementById('chaosModeToggle') ? document.getElementById('chaosModeToggle').checked : false, botMaxSplits: MAX_BOT_CELLS, world: {...worldSettings} };
        if (selectedQuality === 'high') DRAW_LOD_THRESHOLD = 1; else if (selectedQuality === 'normal') DRAW_LOD_THRESHOLD = 3; else if (selectedQuality === 'low') DRAW_LOD_THRESHOLD = 6; else if (selectedQuality === 'ultra') { DRAW_LOD_THRESHOLD = 6; isLowQuality = true; } else { isLowQuality = false; DRAW_LOD_THRESHOLD = 3; }
        isSpectating = true; gameRunning = true; isGodMode = false;
        if (currentGameMode === 'classic') { MAP_SIZE = WORLD_CONFIG.classic.size; els.actionBar.style.display = 'none'; } else { MAP_SIZE = WORLD_CONFIG.arcade.size; els.actionBar.style.display = 'none'; } MAP_SIZE *= worldSettings.map;
        let roomKey = currentGameMode + '_' + currentServer; if (!roomTimers[roomKey] || roomTimers[roomKey] <= Date.now()) { if(GAME_DURATION_MS) roomTimers[roomKey] = Date.now() + GAME_DURATION_MS; }
        let needsRegen = !roomStates[roomKey]; if (needsRegen) { let newData = generateWorldData(); foods = newData.foods; viruses = newData.viruses; enemies = newData.enemies; projectiles = []; ejectedMasses = []; explosions = []; roomStates[roomKey] = { foods, viruses, enemies, projectiles, ejected: ejectedMasses, config: currentBotConfig }; } else { let s = roomStates[roomKey]; if(s) { foods = s.foods; viruses = s.viruses; enemies = s.enemies; projectiles = s.projectiles; ejectedMasses = s.ejected; if(s.config) { botConfig.enabled = s.config.botEnabled; botConfig.count = s.config.botCount; botConfig.respawn = s.config.botRespawn; } } else { let newData = generateWorldData(); foods = newData.foods; viruses = newData.viruses; enemies = newData.enemies; } }
        player.cells = []; els.loginOverlay.style.display = 'none'; els.result.style.display = 'none'; els.skillOverlay.style.display = 'none'; document.getElementById('ui').style.display = 'flex'; document.getElementById('leaderboard').style.display = 'block'; document.getElementById('timerDisplay').style.display = 'block'; document.getElementById('exitGameBtn').style.display = 'flex'; 
        if (!isSpectating) { camera.x = 0; camera.y = 0; camera.scale = 0.1; } SoundManager.playMusic();
    }

    function stopGame() { isSpectating = true; SoundManager.stopMusic(); SoundManager.stop('timer'); SoundManager.play('death'); els.skillOverlay.style.display = 'none'; isPickingSkill = false; saveCurrentRoomState(); if(saveInterval) clearInterval(saveInterval); localStorage.removeItem('pillwars_save'); setTimeout(() => { els.resultTitle.innerText = "GAME OVER"; els.resultTitle.style.color = "#ff2a2a"; showResultsUI(); }, 1400); }
    function showResultsUI() { document.getElementById('exitGameBtn').style.display = 'none'; let all = [{name: player.name, m: 0, isMe: true}]; player.cells.forEach(c => all[0].m += c.mass); enemies.forEach(e => all.push({name: e.name, m: e.mass, isMe: false})); all.sort((a,b) => b.m - a.m); let html = ''; all.slice(0, 3).forEach((e, i) => { let ds = SHOW_MASS_AS_SCORE ? Math.floor(e.m) : Math.floor(Math.sqrt(e.m/Math.PI)); html += `<li class="winner-item"><span>#${i+1} ${e.name}</span><span>${ds}</span></li>`; }); els.winnerList.innerHTML = html; let myRank = all.findIndex(e => e.isMe) + 1; els.myResult.innerText = (myRank > 0 && myRank <= 3) ? `YOU WERE TOP ${myRank}!` : `FINISHED RANK: ${myRank}`; els.myResult.style.color = (myRank > 0 && myRank <= 3) ? '#00ff88' : '#ccc'; els.result.style.display = 'flex'; hideGameHUD(); }
    function finishGameSuccess() { SoundManager.play('select'); SoundManager.stopMusic(); SoundManager.stop('timer'); isSpectating = true; saveCurrentRoomState(); if(saveInterval) clearInterval(saveInterval); localStorage.removeItem('pillwars_save'); els.resultTitle.innerText = "MATCH FINISHED"; els.resultTitle.style.color = "#00ff88"; showResultsUI(); }
    function returnToMenu() { SoundManager.play('select'); SoundManager.stopMusic(); SoundManager.stop('timer'); els.skillOverlay.style.display = 'none'; isPickingSkill = false; els.result.style.display = 'none'; document.getElementById('ui').style.display = 'none'; els.loginOverlay.style.display = 'flex'; gameRunning = false; isSpectating = false; document.getElementById('exitGameBtn').style.display = 'none'; if(saveInterval) clearInterval(saveInterval); checkActiveRoomConfig(); }
    function checkActiveRoomConfig() {
        if (!currentGameMode) return;
        let roomKey = currentGameMode + '_' + currentServer;
        let slider = document.getElementById('botCountInput'), toggle = document.getElementById('botsToggle'), respawnToggle = document.getElementById('botRespawnToggle'), chaosToggle = document.getElementById('chaosModeToggle'), splitLimit = document.getElementById('botSplitLimit');
        let mapMult = document.getElementById('mapMult'), foodMult = document.getElementById('foodMult'), virusMult = document.getElementById('virusMult'), speedMult = document.getElementById('speedMult');
        let chaosBox = document.getElementById('chaosModeContainer');
        let btn = document.getElementById('btnEnterGame');
        if (saveSystem.hasSaveForRoom(currentGameMode, currentServer)) { btn.innerText = "RESUME GAME"; btn.style.background = "#ffd700"; btn.style.color = "#000"; } else { btn.innerText = "ENTER ARENA"; btn.style.background = "var(--accent)"; btn.style.color = "#fff"; }
        if (roomStates[roomKey] && roomStates[roomKey].config) {
            let config = roomStates[roomKey].config;
            slider.value = config.botCount; document.getElementById('botCountVal').innerText = config.botCount; toggle.checked = config.botEnabled; respawnToggle.checked = config.botRespawn; if(chaosToggle) chaosToggle.checked = config.chaosMode;
            if (config.botMaxSplits) splitLimit.value = config.botMaxSplits;
            if (config.world) { mapMult.value = config.world.map; foodMult.value = config.world.food; virusMult.value = config.world.virus; if(config.world.speed) speedMult.value = config.world.speed; }
            slider.disabled = true; toggle.disabled = true; respawnToggle.disabled = true; splitLimit.disabled = true; mapMult.disabled = true; foodMult.disabled = true; virusMult.disabled = true; speedMult.disabled = true; if(chaosToggle) chaosToggle.disabled = true;
            document.getElementById('settingsControls').style.opacity = "0.5"; document.getElementById('settingsControls').style.pointerEvents = "none"; document.getElementById('settingsControls').style.filter = "grayscale(1)";
            if(chaosBox) { chaosBox.style.opacity = "0.5"; chaosBox.style.pointerEvents = "none"; chaosBox.style.filter = "grayscale(1)"; }
        } else {
            slider.disabled = false; toggle.disabled = false; respawnToggle.disabled = false; splitLimit.disabled = false; mapMult.disabled = false; foodMult.disabled = false; virusMult.disabled = false; speedMult.disabled = false; if(chaosToggle) chaosToggle.disabled = false;
            if (!splitLimit.getAttribute('data-user-set')) { splitLimit.value = (currentGameMode === 'classic') ? "8" : "4"; }
            document.getElementById('settingsControls').style.opacity = "1"; document.getElementById('settingsControls').style.pointerEvents = "auto"; document.getElementById('settingsControls').style.filter = "none";
            if(chaosBox) { chaosBox.style.opacity = "1"; chaosBox.style.pointerEvents = "auto"; chaosBox.style.filter = "none"; }
        }
        MAX_BOT_CELLS = parseInt(splitLimit.value); toggleBotOptions();
    }
    function hideGameHUD() { document.getElementById('ui').style.display = 'none'; document.getElementById('actionBar').style.display = 'none'; document.getElementById('leaderboard').style.display = 'none'; document.getElementById('buffTable').style.display = 'none'; document.getElementById('timerDisplay').style.display = 'none'; document.getElementById('skillChoiceOverlay').style.display = 'none'; els.buffList.innerHTML = ""; }
    function saveCurrentRoomState() { let roomKey = currentGameMode + '_' + currentServer; let prevConfig = (roomStates[roomKey] && roomStates[roomKey].config) ? roomStates[roomKey].config : null; roomStates[roomKey] = { foods, viruses, enemies, projectiles, ejected: ejectedMasses, config: prevConfig }; }
    function spawnBot() { if (!botConfig.enabled) return; let p = getSafePos(MAP_SIZE); let name = BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)]; enemies.push(new Cell(p.x, p.y, Math.random() * 5 + 14, getRandomColor(), getRandomColor(), name, true, null)); }
    function spawnFood() { 
        spawnFoodSafe(foods, MAP_SIZE);
    }
    function spawnVirus() { spawnVirusSafe(viruses, MAP_SIZE); }
    function getSafePos(limit) { let attempts = 0; while (attempts < 100) { let x = Math.random() * limit * 0.9 - limit * 0.45; let y = Math.random() * limit * 0.9 - limit * 0.45; let isSafe = true; let allEntities = [...enemies, ...player.cells]; for (let e of allEntities) { if (e.mass === 0) continue; let dist = Math.hypot(x - e.x, y - e.y); if (dist < 600 + (e.r * 4)) { isSafe = false; break; } } if (isSafe) return { x: x, y: y }; attempts++; } return { x: Math.random() * limit * 0.8 - limit * 0.4, y: Math.random() * limit * 0.8 - limit * 0.4 }; }

    function emitProjectile(type, cost) {
        let best = null, minD = Infinity, es = getViewScale(), wMX = (mouse.x - width/2) / es + camera.x, wMY = (mouse.y - height/2) / es + camera.y;
        player.cells.forEach(c => { if (c.mass - cost > 314) { let d = Math.hypot(c.x - wMX, c.y - wMY); if(d < minD) { minD = d; best = c; } } });
        if(best) { 
            let c = best; c.r = Math.sqrt((c.mass - cost) / (Math.PI * PILL_RATIO)); 
            let a = Math.atan2(wMY - c.y, wMX - c.x); let relAngle = a - (-Math.PI / 4); let edgeDist = (c.r * (c.r * PILL_RATIO)) / Math.sqrt(Math.pow((c.r * PILL_RATIO) * Math.cos(relAngle), 2) + Math.pow(c.r * Math.sin(relAngle), 2));
            let spawnDist = edgeDist + 25; let spd = (type==='shoot')?20:40; let r = (type==='shoot')?12:16;
            let obj = { x: c.x + Math.cos(a) * spawnDist, y: c.y + Math.sin(a) * spawnDist, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd, r, angle: Math.random()*Math.PI, type }; 
            if(type==='shoot') { obj.c1 = '#ff2a2a'; obj.c2 = '#fff'; } else { obj.c1 = c.colorBot; obj.c2 = c.colorTop; } 
            ejectedMasses.push(obj); SoundManager.play('shoot');
        }
    }

    function performSplit(cell, angle) {
        let nR = cell.r / 1.414; cell.r = nR; cell.bornTime = Date.now(); 
        let s = new Cell(cell.x + Math.cos(angle)*cell.r*2, cell.y + Math.sin(angle)*cell.r*2, nR, cell.colorBot, cell.colorTop, cell.name, cell.isBot, (cell.skin?cell.skin.src:null), cell.id);
        if (cell.isBot) { s.botSkills = [...cell.botSkills]; s.botGcd = cell.botGcd; s.botNextSkillTime = cell.botNextSkillTime; s.massMilestoneMet = cell.massMilestoneMet; s.magnetTime = cell.magnetTime; s.sprintTime = cell.sprintTime; s.immuneTime = cell.immuneTime; }
        s.boostX = Math.cos(angle) * SPLIT_FORCE; s.boostY = Math.sin(angle) * SPLIT_FORCE;
        if (cell.isBot) enemies.push(s); else player.cells.push(s);
        if(cell.isBot) { if (enableEnemySnd) SoundManager.play('split', {x: cell.x, y: cell.y}); } else { SoundManager.playSplit(); }
    }

    function splitPlayer() { 
        if (Date.now() - lastSplitTime < SPLIT_COOLDOWN_MS || player.cells.length >= MAX_CELLS) return; 
        let did = false; let es = getViewScale(); let wMX = (mouse.x - width/2) / es + camera.x; let wMY = (mouse.y - height/2) / es + camera.y;
        for(let i = player.cells.length - 1; i >= 0; i--) { let c = player.cells[i]; if (c.r >= 35 && player.cells.length < MAX_CELLS) { let a = Math.atan2(wMY - c.y, wMX - c.x); performSplit(c, a); did = true; } }
        if (did) lastSplitTime = Date.now();
    }
    
    function triggerRandomSplit() { if (player.cells.length >= MAX_CELLS) return; let newC = []; player.cells.forEach(c => { if (c.r >= 35 && player.cells.length + newC.length < MAX_CELLS) { let nR = c.r / 1.414; c.r = nR; c.bornTime = Date.now(); let a = Math.random() * Math.PI * 2; let s = new Cell(c.x + Math.cos(a)*c.r*2, c.y + Math.sin(a)*c.r*2, nR, c.colorBot, c.colorTop, c.name, false, (c.skin?c.skin.src:null), c.id); s.boostX = Math.cos(a) * SPLIT_FORCE; s.boostY = Math.sin(a) * SPLIT_FORCE; newC.push(s); } }); player.cells = player.cells.concat(newC); createExplosion(player.cells[0].x, player.cells[0].y); }
    
    function handleVirusCollision(v, vIdx, cell, isP = false) { 
        createExplosion(v.x, v.y); if (vIdx !== -1) { virusPool.free(viruses[vIdx]); viruses.splice(vIdx, 1); } spawnVirus(); 
        if (cell.isBot) { if(enableEnemySnd) SoundManager.play('virus', {x: v.x, y: v.y}); } else { SoundManager.play('virus'); }
        if (!isP) { let g = (cell.mass < VIRUS_GAIN_THRESHOLD) ? VIRUS_GAIN_LOW : VIRUS_GAIN_HIGH; cell.r = Math.sqrt((cell.mass + g) / (Math.PI * PILL_RATIO)); if(!cell.isBot) spawnFloatingText("VIRUS GAIN MASS+", "#00FF00", true); } 
        if(cell.immuneTime > 0) return; 
        let list = cell.isBot ? enemies : player.cells; let lim = MAX_CELLS; let myCount = 0;
        if (cell.isBot) { for(let e of enemies) if(e.id === cell.id) myCount++; } else { myCount = player.cells.length; }
        if(myCount >= lim) return; 
        cell.r /= 1.732; cell.bornTime = Date.now(); 
        for(let k=0; k<2; k++) { 
            let currentCountCheck = 0; if (cell.isBot) { for(let e of enemies) if(e.id === cell.id) currentCountCheck++; } else { currentCountCheck = player.cells.length; } if(currentCountCheck >= lim) break; 
            let a = Math.random() * Math.PI * 2; let f = new Cell(cell.x, cell.y, cell.r, cell.colorBot, cell.colorTop, cell.name, cell.isBot, (cell.skin?cell.skin.src:null), cell.id); 
            if (cell.isBot) { f.botSkills = [...cell.botSkills]; f.botGcd = cell.botGcd; f.botNextSkillTime = cell.botNextSkillTime; f.massMilestoneMet = cell.massMilestoneMet; f.magnetTime = cell.magnetTime; f.sprintTime = cell.sprintTime; f.immuneTime = cell.immuneTime; }
            f.boostX = Math.cos(a) * 45; f.boostY = Math.sin(a) * 45; list.push(f); 
        } 
    }
    function lerpColor(a, b, amount) { if (typeof amount !== 'number') return a; var ah = parseInt(a.replace(/#/g, ''), 16), ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff, bh = parseInt(b.replace(/#/g, ''), 16), br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff, rr = ar + amount * (br - ar), rg = ag + amount * (bg - ag), rb = ab + amount * (bb - ab); return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1); }
    function createExplosion(x, y) { explosions.push(new Explosion(x, y)); }

    function showSkillChoice() { if(isPickingSkill) return; SoundManager.play('alert'); SoundManager.play('timer'); isPickingSkill = true; pickTimer = 10; skillChoiceIndex = 0; let pool = [1, 2, 3, 4, 5, 6, 7, 8], opts = []; while(opts.length < 2) { let r = pool[Math.floor(Math.random()*pool.length)]; if(!opts.includes(r)) opts.push(r); } els.skillOpts.innerHTML = ''; opts.forEach((id, index) => { let s = skills[id], div = document.createElement('div'); div.className = 'skill-opt-btn'; if (index === 0) div.classList.add('selected-choice'); div.innerHTML = `<div class="skill-opt-icon ${s.icon}" style="background-color:transparent;"></div><div class="skill-opt-name">${s.name}</div>`; div.onmouseenter = () => { SoundManager.playSimpleHover(); skillChoiceIndex = index; updateChoiceVisuals(); }; div.onclick = () => { selectArcadeSkill(id); }; els.skillOpts.appendChild(div); }); els.skillOverlay.style.display = 'flex'; }
    function updateChoiceVisuals() { let buttons = els.skillOpts.children; for (let i = 0; i < buttons.length; i++) { if (i === skillChoiceIndex) buttons[i].classList.add('selected-choice'); else buttons[i].classList.remove('selected-choice'); } }
    function selectArcadeSkill(id) { SoundManager.play('simpleselect'); SoundManager.stop('timer'); els.skillOverlay.style.display = 'none'; isPickingSkill = false; let idx = playerSkills.findIndex(s => s && s.id === id); if (idx !== -1) { playerSkills[idx].uses += skills[id].uses; } else { let slot = playerSkills.indexOf(null); if(slot === -1) slot = 3; playerSkills[slot] = { id, uses: skills[id].uses }; } updateSkillsUI_Arcade(); }
    
    function isHiddenInVirus(cell) { for(let v of viruses) { if (cell.r < v.r && getEllipticalDist(cell, v) + cell.r < v.r) { return true; } } return false; }

    function updateGame() {
        if (!gameRunning) return;
        let totalM = 0; player.cells.forEach(c => totalM += c.mass);
        const now = Date.now(), delta = now - lastFrameTime; lastFrameTime = now;
        if(globalCDTimer > 0) { globalCDTimer -= delta; if(globalCDTimer < 0) globalCDTimer = 0; }
        fpsTimer += delta; frameCount++; if (fpsTimer >= 1000) { els.fpsVal.innerText = frameCount; fpsTimer = 0; frameCount = 0; }
        let gcdText = globalCDTimer > 0 ? (globalCDTimer/1000).toFixed(1) : ""; for(let i=1; i<=10; i++) { if(uiGcds[i]) uiGcds[i].innerText = gcdText; }
        
        let activeBuffs = []; if (skills[3].active > 0) activeBuffs.push({id: 3, time: skills[3].active}); if (skills[5].active > 0) activeBuffs.push({id: 5, time: skills[5].active}); if (skills[6].active > 0) activeBuffs.push({id: 6, time: skills[6].active});
        // CORREGIDO: Rutas a im√°genes con ../
        if(activeBuffs.length > 0) { els.buffTable.style.display = 'block'; let buffHtml = ""; const buffImages = { 3: '../img/sprint.png', 5: '../img/iman.png', 6: '../img/inmune.png' }; activeBuffs.forEach(buff => { let seconds = Math.ceil(buff.time / 1000); let imgSrc = buffImages[buff.id] || ''; buffHtml += `<div class="buff-row"><img src="${imgSrc}" class="buff-icon-img" onerror="this.style.display='none'"><span class="buff-time">${seconds}s</span></div>`; }); els.buffList.innerHTML = buffHtml; } else { els.buffTable.style.display = 'none'; }

        let roomKey = currentGameMode + '_' + currentServer;
        if (currentGameMode === 'arcade' || currentGameMode === 'skills') { 
            let tl = roomTimers[roomKey] - Date.now(); 
            if(tl <= 0) { finishGameSuccess(); return; } 
            let min = Math.floor(tl/60000), sec = Math.floor((tl%60000)/1000); els.timer.innerText = (min<10?"0"+min:min) + ":" + (sec<10?"0"+sec:sec); 
            if(!isGodMode && !isSpectating) { let elapsed = (GAME_DURATION_MS - tl) / 1000; if (elapsed > nextSkillPickTime) { showSkillChoice(); nextSkillPickTime += 30; } if(totalM >= 1000 && !massMilestoneReached) { massMilestoneReached = true; showSkillChoice(); } if(isPickingSkill) { pickTimer -= (1/60) * timeScale; els.skillTimer.style.width = (pickTimer * 10) + "%"; if(pickTimer <= 0) { els.skillOverlay.style.display = 'none'; isPickingSkill = false; SoundManager.stop('timer'); } } } 
        } else { els.timer.innerText = ""; }
        
        if (isGodMode) { els.debugHud.style.display = 'block'; } else { els.debugHud.style.display = 'none'; }
        for(let i=1; i<=8; i++) { if(skills[i].active > 0) { skills[i].active -= delta; if(skills[i].active < 0) skills[i].active = 0; } }
        if (currentGameMode === 'arcade' || currentGameMode === 'skills') { for(let i=0; i<10; i++) { let slot = i+1, s = playerSkills[i]; if(s && uiCounts[slot]) { uiCounts[slot].innerText = isGodMode ? "‚àû" : s.uses; if(s.uses <= 0 && !isGodMode) uiSlots[slot].style.opacity = '0.5'; } } }
        
        foodGrid.clear();
        for(let f of foods) foodGrid.insert(f);

        if(skills[5].active > 0) { player.cells.forEach(p => { if(p.tpPhase > 0) return; foods.forEach(f => { let dx = p.x - f.x, dy = p.y - f.y, dist = Math.sqrt(dx*dx+dy*dy); if(dist < (SKILL_PARAMS.magnetRange + p.r) && dist > 1) { f.x += (dx/dist)*3 * timeScale; f.y += (dy/dist)*3 * timeScale; } }); }); }

        let tx=0, ty=0, totalR=0, n=player.cells.length; player.cells.forEach(c => { tx+=c.x; ty+=c.y; totalR+=c.r; c.groupMaxR = Math.max(...player.cells.map(x=>x.r)); }); els.score.innerText = Math.floor(totalM);
        if (totalM >= AUTO_SPLIT_LEVEL_1 && !splitMilestones.level1) { triggerRandomSplit(); splitMilestones.level1 = true; }
        if (totalM >= AUTO_SPLIT_LEVEL_2 && !splitMilestones.level2) { triggerRandomSplit(); splitMilestones.level2 = true; }
        
        if (isSpectating) {
            let specR = 178; let targetScale = ZOOM_CONFIG.baseScale * Math.pow(INITIAL_RADIUS / specR, ZOOM_CONFIG.exponent); targetScale = Math.max(ZOOM_CONFIG.minScale, Math.min(ZOOM_CONFIG.maxScale, targetScale)); camera.scale += (targetScale - camera.scale) * 0.05 * timeScale;
            if (isSpecDragging) { let es = getViewScale(); let dx = (mouse.x - lastSpecX) / es; let dy = (mouse.y - lastSpecY) / es; camera.x -= dx * 1.5; camera.y -= dy * 1.5; lastSpecX = mouse.x; lastSpecY = mouse.y; }
        } else {
            if(n > 0) { camera.x += ((tx/n) - camera.x) * 0.05 * timeScale; camera.y += ((ty/n) - camera.y) * 0.05 * timeScale; let effR = Math.max(INITIAL_RADIUS, totalR / Math.pow(n, 0.4)); let targetScale = ZOOM_CONFIG.baseScale * Math.pow(INITIAL_RADIUS / effR, ZOOM_CONFIG.exponent); targetScale = Math.max(ZOOM_CONFIG.minScale, Math.min(ZOOM_CONFIG.maxScale, targetScale)); camera.scale += (targetScale - camera.scale) * 0.05 * timeScale; }
        }

        explosions.forEach((e, i) => { e.update(); if(e.life <= 0) explosions.splice(i, 1); });
        floatingTexts.forEach((ft, i) => { ft.update(); if(ft.life <= 0) floatingTexts.splice(i, 1); });
        uiTexts.forEach((ut, i) => { ut.update(); if(ut.life <= 0) uiTexts.splice(i, 1); });

        let living = [...player.cells, ...enemies];
        for(let i=ejectedMasses.length-1; i>=0; i--) { 
            let m = ejectedMasses[i], f = (m.type === 'shoot') ? 0.93 : 0.9; m.x += m.vx * timeScale; m.y += m.vy * timeScale; m.vx *= Math.pow(f, timeScale); m.vy *= Math.pow(f, timeScale); 
            if (m.type === 'shoot') { for(let c of living) { if(getEllipticalDist(m, c) < c.r) { createExplosion(m.x, m.y); ejectedMasses.splice(i, 1); break; } } } 
            for(let c of living) { if(getEllipticalDist(m, c) < c.r) { c.r = Math.sqrt((c.mass + (Math.PI*m.r*m.r*2))/(Math.PI*PILL_RATIO)); ejectedMasses.splice(i, 1); break; } } 
            if(i < ejectedMasses.length) { 
                for(let vIdx=0; vIdx<viruses.length; vIdx++) { 
                    let v = viruses[vIdx]; 
                    if(Math.hypot(m.x-v.x, m.y-v.y) < v.r) { 
                        if(m.type === 'shoot') { ejectedMasses.splice(i, 1); if(!v.damaged) { v.damaged = true; v.animTime = 0; createExplosion(v.x, v.y); } else { createExplosion(v.x, v.y); virusPool.free(viruses[vIdx]); viruses.splice(vIdx, 1); projectiles.push({ x: v.x, y: v.y, vx: Math.cos(Math.atan2(m.vy, m.vx))*20, vy: Math.sin(Math.atan2(m.vy, m.vx))*20, r: 25, type: 'virusShot' }); spawnVirus(); } } 
                        else { ejectedMasses.splice(i, 1); createExplosion(v.x, v.y); v.hits = (v.hits||0) + 1; v.r += 6; if(v.hits >= 2) { v.hits = 0; v.r = 70; let a = Math.atan2(m.vy, m.vx); let vNew = virusPool.get(); vNew.x = v.x+Math.cos(a)*55; vNew.y = v.y+Math.sin(a)*55; vNew.r = 70; vNew.vx = Math.cos(a)*30; vNew.vy = Math.sin(a)*30; vNew.hits = 0; vNew.damaged = false; viruses.push(vNew); if((currentGameMode === 'arcade' || currentGameMode === 'skills') && !isGodMode && !isSpectating) showSkillChoice(); } } 
                        break; 
                    } 
                }
            }
        }

        for(let i=projectiles.length-1; i>=0; i--) { let p = projectiles[i]; p.x += p.vx * timeScale; p.y += p.vy * timeScale; if (Math.abs(p.x) > MAP_SIZE || Math.abs(p.y) > MAP_SIZE) { projectiles.splice(i,1); continue; } for(let c of living) { if(c.immuneTime > 0 || c.tpPhase > 0) continue; if(getEllipticalDist(p, c) < c.r + p.r) { createExplosion(c.x, c.y); handleVirusCollision({x:c.x, y:c.y}, -1, c, true); projectiles.splice(i, 1); break; } } }

        for(let i=0; i<viruses.length; i++) { 
            let v = viruses[i]; if (v.damaged && v.animTime < 1) { v.animTime += 0.015 * timeScale; if(v.animTime > 1) v.animTime = 1; }
            v.x += v.vx * timeScale; v.y += v.vy * timeScale; v.vx *= Math.pow(0.94, timeScale); v.vy *= Math.pow(0.94, timeScale); 
            if(Math.abs(v.x) > MAP_SIZE) v.vx*=-1; if(Math.abs(v.y) > MAP_SIZE) v.vy*=-1; 
            for(let c of living) { if(c.immuneTime > 0 || c.tpPhase > 0) continue; let vulnerable = (c.mass >= 15000) || (c.r > v.r); if (((v.vx**2 + v.vy**2) > 25 && getEllipticalDist(c, v) < c.r + v.r - 10) || (vulnerable && getEllipticalDist(c, v) < c.r * 0.9)) { handleVirusCollision(v, i, c, false); i--; break; } } 
        }

        for(let i=0; i<player.cells.length; i++) { let p = player.cells[i]; p.update(delta); for(let j=i+1; j<player.cells.length; j++) resolveCellCollision(p, player.cells[j], true); }
        player.cells = player.cells.filter(c => c.r > 0); if(player.cells.length === 0 && gameRunning && !isSpectating) stopGame();

        enemies.forEach(bot => { let siblings = enemies.filter(e => e.id === bot.id); let maxR = 0; siblings.forEach(s => { if(s.r > maxR) maxR = s.r; }); bot.groupMaxR = maxR; bot.update(delta); });
        
        for(let i=enemies.length-1; i>=0; i--) { 
            let bot = enemies[i]; if (bot.r <= 0) { enemies.splice(i,1); continue; } 
            for(let k=player.cells.length-1; k>=0; k--) { 
                let p = player.cells[k]; if (p.tpPhase > 0 || bot.tpPhase > 0) continue; if (p.immuneTime > 0 && bot.r > p.r) continue; if (bot.immuneTime > 0 && p.r > bot.r) continue;
                if (currentGameMode === 'classic' && currentKillStreak >= 5) continue; let botHiding = isHiddenInVirus(bot); let playerHiding = isHiddenInVirus(p);
                if(!isGodMode && bot.r > p.r*1.15 && getEllipticalDist(bot, p) < bot.r*0.8 && !playerHiding) { bot.r = Math.sqrt((bot.mass+p.mass)/(Math.PI*PILL_RATIO)); player.cells.splice(k,1); } 
                else if(p.r > bot.r*1.15 && getEllipticalDist(p, bot) < p.r*0.8 && !botHiding) { 
                    p.r = Math.sqrt((p.mass+bot.mass)/(Math.PI*PILL_RATIO)); let botId = bot.id; let botName = bot.name; enemies.splice(i,1); 
                    let remainingPieces = enemies.filter(e => e.id === botId).length;
                    if (remainingPieces === 0) {
                        if (currentGameMode === 'classic') { 
                            currentKillStreak++; let msg = "KILL";
                            if (currentKillStreak === 1) msg = "FIRST BLOOD"; else if (currentKillStreak === 2) msg = "DOUBLE KILL"; else if (currentKillStreak === 3) msg = "TRIPLE KILL"; else if (currentKillStreak === 4) msg = "QUADRA KILL"; else if (currentKillStreak >= 5) msg = "PENTAKILL"
                            spawnFloatingText(msg, "#FF0000", true); SoundManager.playFloatKill(); if (currentKillStreak >= 5) setTimeout(() => finishGameSuccess(), 1000); 
                        } else { 
                            const taunts = ["REKT", "PWNED", "BYE", "EZ", "BOOM", "SIT DOWN", "LATER", "DELETED"]; let randomMsg = taunts[Math.floor(Math.random() * taunts.length)];
                            spawnFloatingText(randomMsg + " " + botName, "#FF2A2A", true); SoundManager.playFloatKill(); 
                        }
                        if(botConfig.respawn) setTimeout(spawnBot, 3000); 
                    } else { SoundManager.play('kill1'); }
                    i--; break; 
                }
            } 
            if(i < 0 || i >= enemies.length) continue;
            for(let j=i-1; j>=0; j--) { 
                let other = enemies[j]; resolveCellCollision(bot, other, bot.id === other.id); 
                if (bot.id !== other.id) { 
                     if (bot.r > other.r * 1.15 && getEllipticalDist(bot, other) < bot.r * 0.6) { if (!isHiddenInVirus(other) && other.immuneTime <= 0) { bot.r = Math.sqrt((bot.mass + other.mass) / (Math.PI * PILL_RATIO)); let otherId = other.id; enemies.splice(j, 1); let remaining = enemies.filter(e => e.id === otherId).length; if (remaining === 0 && botConfig.respawn) setTimeout(spawnBot, 3000); i--; } }
                     else if (other.r > bot.r * 1.15 && getEllipticalDist(other, bot) < other.r * 0.6) { if (!isHiddenInVirus(bot) && bot.immuneTime <= 0) { other.r = Math.sqrt((other.mass + bot.mass) / (Math.PI * PILL_RATIO)); let botId = bot.id; enemies.splice(i, 1); let remaining = enemies.filter(e => e.id === botId).length; if (remaining === 0 && botConfig.respawn) setTimeout(spawnBot, 3000); break; } }
                }
            }
        }
        
        living = [...player.cells, ...enemies]; let gainMultiplier = worldSettings.food || 1;
        living.forEach(c => {
            const nearbyFoods = foodGrid.query(c.x, c.y);
            for(let f of nearbyFoods) {
                if(f.eaten) continue;
                if(getEllipticalDist(c, f) < c.r + f.r) {
                    let gain = (Math.PI*f.r*f.r*2.5) * gainMultiplier;
                    c.r = Math.sqrt((c.mass + gain)/(Math.PI*PILL_RATIO));
                    f.eaten = true;
                }
            }
        });

        for (let i = foods.length - 1; i >= 0; i--) {
            if (foods[i].eaten) {
                foods[i].eaten = false;
                foodPool.free(foods[i]);
                foods[i] = foods[foods.length - 1];
                foods.pop();
                spawnFood();
            }
        }

        const uniqueIds = new Set(enemies.map(e => e.id)); els.enemyCount.innerText = uniqueIds.size; updateLeaderboard();
    }

    function draw() {
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color'); ctx.fillRect(0, 0, width, height); if (!gameRunning) return;
        let es = getViewScale(); ctx.save(); ctx.translate(width/2, height/2); ctx.scale(es, es); ctx.translate(-camera.x, -camera.y);
        let vL = camera.x - (width/2)/es - 100, vR = camera.x + (width/2)/es + 100, vT = camera.y - (height/2)/es - 100, vB = camera.y + (height/2)/es + 100;
        ctx.lineWidth = 1; ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--grid-line'); let g = 100, sX = Math.floor(vL/g)*g, eX = Math.ceil(vR/g)*g, sY = Math.floor(vT/g)*g, eY = Math.ceil(vB/g)*g; ctx.beginPath(); for(let x = sX; x <= eX; x+=g) { ctx.moveTo(x, vT); ctx.lineTo(x, vB); } for(let y = sY; y <= eY; y+=g) { ctx.moveTo(vL, y); ctx.lineTo(vR, y); } ctx.stroke(); 
        
        ctx.save(); ctx.beginPath(); ctx.lineWidth = 20; ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)'; ctx.shadowBlur = 40; ctx.shadowColor = '#ff0000'; ctx.rect(-MAP_SIZE, -MAP_SIZE, MAP_SIZE*2, MAP_SIZE*2); ctx.stroke();
        ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = '#ff3333'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000'; let dashOffset = (performance.now() / 20) % 60; ctx.setLineDash([30, 30]); ctx.lineDashOffset = -dashOffset; ctx.rect(-MAP_SIZE, -MAP_SIZE, MAP_SIZE*2, MAP_SIZE*2); ctx.stroke(); ctx.restore();

        let spikeCount = 0; if (selectedQuality === 'high') spikeCount = 4; else if (selectedQuality === 'normal') spikeCount = 2; else if (selectedQuality === 'low') spikeCount = 1;

        ctx.save();
        for(let i=0; i<foods.length; i++) { 
            let f = foods[i]; if (f.x > vL && f.x < vR && f.y > vT && f.y < vB) { 
                ctx.fillStyle = f.c1; ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2); ctx.fill(); 
                if (spikeCount > 0 && f.spikes) { for(let j = 0; j < spikeCount; j++) { let ang = f.spikes[j]; ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(ang); ctx.fillStyle = f.c1; ctx.beginPath(); ctx.moveTo(f.r - 1, -f.r/2); ctx.lineTo(f.r + f.r/1.5, 0); ctx.lineTo(f.r - 1, f.r/2); ctx.fill(); ctx.restore(); } }
            } 
        }
        ctx.restore();
        
        ctx.save();
        ejectedMasses.forEach(m => { if (m.x > vL && m.x < vR && m.y > vT && m.y < vB) drawMiniPill(m, es); });
        ctx.restore();

        ctx.save();
        projectiles.forEach(p => { if (p.x > vL && p.x < vR && p.y > vT && p.y < vB) { if (isLowQuality) { ctx.fillStyle = '#9EE32D'; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); } else { ctx.save(); ctx.translate(p.x, p.y); let sL = 5; ctx.fillStyle = '#9EE32D'; ctx.strokeStyle = '#3E8E11'; ctx.lineWidth = 2; ctx.beginPath(); for(let i=0; i<16; i++) { let r=(i%2===0)?p.r + sL:p.r, a=(Math.PI*i)/8; (i===0)?ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r):ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r); } ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); } } });
        ctx.restore();

        explosions.forEach(e => e.draw());
        
        if (skills[5].active > 0 && player.cells.length > 0) { 
            let avgX = 0, avgY = 0, maxR = 0; player.cells.forEach(c => { avgX += c.x; avgY += c.y; if(c.r > maxR) maxR = c.r; }); avgX /= player.cells.length; avgY /= player.cells.length; let magnetRad = SKILL_PARAMS.magnetRange + maxR; 
            let timeLoop = (performance.now() / 1000) % 1; ctx.save(); ctx.translate(avgX, avgY);
            for(let i=0; i<3; i++) { let offset = i * 0.33, t = (timeLoop + offset) % 1, radius = magnetRad * t, opacity = 1 - t; radius = magnetRad - radius; opacity = 1 - opacity; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(160, 32, 240, ${opacity * 0.5})`; ctx.lineWidth = 2 + (opacity * 3); ctx.stroke(); } ctx.restore();
        }

        [...enemies, ...player.cells].sort((a,b) => a.r - b.r).forEach(e => { if (e.x + e.r > vL && e.x - e.r < vR && e.y + e.r > vT && e.y - e.r < vB) {
            e.draw(); if (e.isBot && e.magnetTime > 0 && enableEnemyFX) { let magnetRad = SKILL_PARAMS.magnetRange + e.r; let timeLoop = (performance.now() / 1000) % 1; ctx.save(); ctx.translate(e.x, e.y); for(let i=0; i<3; i++) { let offset = i * 0.33, t = (timeLoop + offset) % 1, radius = magnetRad * t, opacity = 1 - t; radius = magnetRad - radius; opacity = 1 - opacity; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(160, 32, 240, ${opacity * 0.5})`; ctx.lineWidth = 2 + (opacity * 3); ctx.stroke(); } ctx.restore(); }
        }});
        
        ctx.save();
        viruses.forEach(v => { 
            if (v.x + v.r > vL && v.x - v.r < vR && v.y + v.r > vT && v.y - v.r < vB) { 
                ctx.save(); ctx.translate(v.x, v.y);
                let fillColor = '#9EE32D'; let strokeColor = '#3E8E11';
                if (v.damaged) { fillColor = lerpColor('#9EE32D', '#a020f0', v.animTime); strokeColor = lerpColor('#3E8E11', '#501078', v.animTime); if(v.animTime < 1) { ctx.translate((Math.random()-0.5)*4, (Math.random()-0.5)*4); } }
                if (selectedQuality === 'high' || selectedQuality === 'normal') {
                    let grad = ctx.createRadialGradient(0, 0, v.r * 0.2, 0, 0, v.r); grad.addColorStop(0, '#ccff66'); grad.addColorStop(1, fillColor); ctx.fillStyle = grad; ctx.strokeStyle = strokeColor; ctx.lineWidth = 5; ctx.lineJoin = 'round';
                    ctx.beginPath(); const numSpikes = 20; for(let i=0; i<numSpikes; i++) { let angle = (Math.PI * 2 * i) / numSpikes; let nextAngle = (Math.PI * 2 * (i+1)) / numSpikes; let midAngle = (angle + nextAngle) / 2; let rOut = v.r + 5; let xOut = Math.cos(midAngle) * rOut; let yOut = Math.sin(midAngle) * rOut; let rIn = v.r - 5; let xIn = Math.cos(nextAngle) * rIn; let yIn = Math.sin(nextAngle) * rIn; if (i===0) ctx.moveTo(Math.cos(angle)*rIn, Math.sin(angle)*rIn); ctx.quadraticCurveTo(Math.cos(angle + (midAngle-angle)/2) * rOut, Math.sin(angle + (midAngle-angle)/2) * rOut, xOut, yOut); ctx.quadraticCurveTo(Math.cos(midAngle + (nextAngle-midAngle)/2) * rOut, Math.sin(midAngle + (nextAngle-midAngle)/2) * rOut, xIn, yIn); } ctx.closePath(); ctx.fill(); ctx.stroke();
                } else {
                    ctx.fillStyle = fillColor; ctx.strokeStyle = strokeColor; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.beginPath(); for(let i=0; i<24; i++) { let r=(i%2===0)? v.r + 8 : v.r - 2; let a=(Math.PI*i)/12; (i===0)?ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r):ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r); } ctx.closePath(); ctx.fill(); ctx.stroke(); 
                }
                if (v.spots && !isLowQuality) { ctx.fillStyle = 'rgba(0,0,0,0.2)'; v.spots.forEach(spot => { ctx.beginPath(); ctx.arc(spot.x, spot.y, spot.r, 0, Math.PI*2); ctx.fill(); }); }
                ctx.restore(); 
            } 
        });
        ctx.restore();
        
        floatingTexts.forEach(ft => ft.draw(ctx)); ctx.restore(); uiTexts.forEach(ut => ut.draw(ctx));
    }
    
    function drawMiniPill(f, scale) { let sR = f.r * scale; if (isLowQuality || sR < DRAW_LOD_THRESHOLD) { ctx.fillStyle = f.c1; ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill(); } else { ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.angle||0); let w = f.r * 2, h = w * 2.0, r = w / 2; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, r); ctx.clip(); ctx.fillStyle = f.c1; ctx.fillRect(-w/2, -h/2, w, h/2); ctx.fillStyle = f.c2; ctx.fillRect(-w/2, 0, w, h/2); ctx.restore(); } }
    function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
    
    // COLLISION RESOLUTION (Standard Cell-Cell Physics)
    function resolveCellCollision(c1, c2, sameTeam) {
        if (c1.tpPhase > 0 || c2.tpPhase > 0) return;
        let dx = c1.x - c2.x; let dy = c1.y - c2.y; let dist = Math.sqrt(dx*dx + dy*dy); let minDist = c1.r + c2.r;
        if (dist < minDist && dist > 0.001) {
            let pen = minDist - dist;
            if (sameTeam) {
                if (c1.canMerge && c2.canMerge) {
                    if (c1.mass >= c2.mass) { c1.r = Math.sqrt((c1.mass+c2.mass)/(Math.PI*PILL_RATIO)); c2.r = 0; }
                    else { c2.r = Math.sqrt((c2.mass+c1.mass)/(Math.PI*PILL_RATIO)); c1.r = 0; }
                } else {
                    let f = pen / dist * 0.5; // smooth push
                    let tx = dx * f; let ty = dy * f;
                    c1.x += tx; c1.y += ty; c2.x -= tx; c2.y -= ty;
                }
            }
        }
    }

    // UPDATE LEADERBOARD
    function updateLeaderboard() {
        let all = [];
        if (player.cells.length > 0) {
            let m = 0; player.cells.forEach(c => m += c.mass);
            all.push({ name: player.name, mass: m, isMe: true });
        }
        let botMap = new Map();
        enemies.forEach(e => {
            if (!botMap.has(e.id)) botMap.set(e.id, { name: e.name, mass: 0, isMe: false });
            botMap.get(e.id).mass += e.mass;
        });
        for (let b of botMap.values()) all.push(b);
        all.sort((a,b) => b.mass - a.mass);
        
        let html = "";
        for (let i=0; i<Math.min(5, all.length); i++) {
            let p = all[i];
            let displayMass = SHOW_MASS_AS_SCORE ? Math.floor(p.mass) : Math.floor(Math.sqrt(p.mass/Math.PI));
            let cls = p.isMe ? "lb-item is-me" : "lb-item";
            html += `<div class="${cls}"><span>${i+1}. ${p.name}</span><span>${displayMass}</span></div>`;
        }
        els.lbList.innerHTML = html;
    }

    const fpsInterval = 1000 / 60; let then = performance.now();
    function loop() { requestAnimationFrame(loop); const now = performance.now(); const elapsed = now - then; if (elapsed > fpsInterval) { then = now - (elapsed % fpsInterval); timeScale = elapsed / (1000 / 60); if (timeScale > 3) timeScale = 3; updateGame(); draw(); } }
    function initMenuState() { els.modeScreen.style.pointerEvents = 'auto'; document.getElementById('panelClassic').classList.remove('expanded', 'hidden'); document.getElementById('panelArcade').classList.remove('expanded', 'hidden'); setHoverMode('classic'); document.getElementById('contentClassic').style.opacity = '1'; document.getElementById('contentArcade').style.opacity = '0.7'; document.querySelector('.diagonal-divider').style.opacity = '1'; }
    initMenuState(); init();
</script>
</body>
</html>
